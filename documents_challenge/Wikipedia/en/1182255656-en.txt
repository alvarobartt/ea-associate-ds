 | typing = dynamic, strong | implementations = Erlang | dialects = | influenced by = Prolog | influenced = Scala | license = Modified MPL | wikibooks = Erlang Programming Erlang is a general-purpose concurrent programming language and runtime system. The sequential subset of Erlang is a functional language, with strict evaluation, single assignment, and dynamic typing. For concurrency it follows the Actor model. It was designed by Ericsson to support distributed, fault-tolerant, soft-real-time, non-stop applications. The first version was designed and implemented by Joe Armstrong (Programming) in 1986.About the Author http://www.pragprog.com/titles/jaerlang/programming-erlang&lt;/ref&gt; It supports hot swapping so code can be changed without stopping a system. &lt;/ref&gt; Erlang was originally a proprietary language within Ericsson, but was released as open source in 1998. The Ericsson implementation primarily runs interpreted virtual machine code, but it also includes a native code compiler (supported on most but not all platforms), developed by the High Performance Erlang Project (HiPE)&lt;/ref&gt; at Uppsala University. It also now supports interpretation via script as of r11b-4.Creating and managing processes is trivial in Erlang, whereas threads are considered a complicated and error-prone topic in most languages. Though all concurrency is explicit in Erlang, processes communicate using message passing instead of shared variables, which removes the need for locks.Erlang is named after A. K. Erlang. It is sometimes thought that its name is an abbreviation of 'Er'icsson 'Lang'uage, owing to its origin inside Ericsson. According to Bjarne Däcker, who headed the Computer Science Lab at the time, this duality is intentional.Erlang, the mathematician?&lt;!-- Bot generated title --&gt;Functional languageCode looks like this:'''-module'''(fact).
'''-export'''([fac/1]).fac(0) -&gt; 1;
fac(N) -&gt; N * fac(N-1).Below is an implementation of a Quicksort algorithm.''%% quicksort:qsort(List)''
''%% Sort a list of items''
'''-module'''(quicksort).
'''-export'''([qsort/1]).qsort([]) -&gt; [];
qsort([Pivot|Rest]) -&gt;
    qsort([ X || X &lt;- Rest, X &lt; Pivot]) ++ [Pivot] ++ qsort([ Y || Y &lt;- Rest, Y &gt;= Pivot]).The above example recursively invokes the function qsort until nothing remains to be sorted. The expression [ X || X  means “Choose all X where X is a member of Rest and X is less than Pivot”, resulting in a very easy way of handling lists. Since you can evaluate any boolean expression between two different datatypes, the evaluation is straightforward: for example, 1  will return true.A compare function can be used, however, if the order on which Erlang bases its return value (true or false) needs to be changed. If, for example, we want an ordered list where a  evaluates true.The following code would sort lists according to length:'''-module'''(listsort).
'''-export'''([by_length/1]). by_length(Lists) -&gt;
    F = fun(A,B) when is_list(A), is_list(B) -&gt;
            length(A) &lt; length(B)
        end,
    qsort(Lists, F). qsort([], _)-&gt; [];
 qsort([Pivot|Rest], Smaller) -&gt;
     qsort([ X || X &lt;- Rest, Smaller(X,Pivot)], Smaller)
     ++ [Pivot] ++
     qsort([ Y ||Y &lt;- Rest, not(Smaller(Y, Pivot))], Smaller).Concurrency and distribution oriented languageErlang's main strength is support for concurrency. It has a small but powerful set of primitives to create processes and communicate between them. Processes are the primary means to structure an Erlang application. Erlang processes are neither operating system processes nor operating system threads, but lightweight processes somewhat similar to Java's original “green threads” (the Java Virtual Machine now uses native threads). Like operating system processes (and unlike green threads and operating system threads) they have no shared state between them. The estimated minimal overhead for each is 300 words (4 bytes per word on 32-bit platforms, 8 bytes per word on 64-bit platforms), so many of them can be created without degrading performance (a benchmark with 20 million processes was tried). Erlang has supported symmetric multiprocessing since release R11B of May 2006.Process communication is done via a share-nothing asynchronous message passing system: every process has a “mailbox”, a queue of messages sent by other processes, that are not yet consumed. A process uses the receive primitive to retrieve messages that match desired patterns. A message-handling routine tests messages in turn against each pattern, until one of them matches. When the message is consumed (removed from the mailbox) the process resumes execution. A message may comprise any Erlang structure, including primitives (integers, floats, characters, atoms), tuples, lists, and functions.Code examples:''% create process and call the function web:start_server(Port, MaxConnections)''
ServerProcess = '''spawn''' (web, start_server, [Port, MaxConnections]),''% create a remote process and call the function web:start_server(Port, MaxConnections) on machine RemoteNode''
RemoteProcess = '''spawn'''(RemoteNode, web, start_server, [Port, MaxConnections]),''% send the  message (a tuple with an atom &quot;pause&quot; and a number &quot;10&quot;) to ServerProcess (asynchronously)''
ServerProcess ! ,''% receive messages sent to this process''
'''receive'''       
        a_message -&gt; do_something; 
         -&gt; handle(DataContent);
         -&gt; io:format(&quot;Got hello message: ~s&quot;, [Text]);
         -&gt; io:format(&quot;Got goodbye message: ~s&quot;, [Text])
'''end'''.As the example shows, there is built-in support for distributed processes. Processes may be created on remote nodes, and communication with them is transparent (i.e. the communication with remote processes is done exactly as the communication with local processes).Concurrency supports the primary method of error-handling in Erlang. When a process crashes, it neatly exits and sends a message to the controlling process which can take action. This way of error handling may increase maintainability and reduce complexity of code.Hot code loading and modulesCode is loaded and managed as "module" units, the module is a compilation unit. The system can keep two versions of a module in memory at the same time, and processes can concurrently run code from each. The versions are referred to the "new" and the "old" version. A process will not move into the new version until it makes an external call to its module.An example of the mechanism of hot code loading: %% A process whose only job is to keep a counter.
 %% First version
 -module(counter).
 -export([start/0, codeswitch/1]). start() -&gt; loop(0). loop(Sum) -&gt;
   receive
       -&gt;
         loop(Sum+Count);
       -&gt;
         Pid ! ,
         loop(Sum);
      code_switch -&gt;
         ?MODULE:codeswitch(Sum)
   end. codeswitch(Sum) -&gt; loop(Sum).For the second version, we add the possibility to reset the count to zero. %% Second version
 -module(counter).
 -export([start/0, codeswitch/1]). start() -&gt; loop(0). loop(Sum) -&gt;
   receive
       -&gt;
         loop(Sum+Count);
      reset -&gt;
         loop(0);
       -&gt;
         Pid ! ,
         loop(Sum);
      code_switch -&gt;
         ?MODULE:codeswitch(Sum)
   end. codeswitch(Sum) -&gt; loop(Sum).Only when receiving a message consisting of the atom 'code_switch' will the loop execute an external call to codeswitch/1 (?MODULE is a preprocessor macro for the current module). If there is a new version of the "counter" module in memory, then its codeswitch/1 function will be called. The practice of having a specific entry-point into a new version allows the programmer to transform state to what is required in the newer version. In our example we keep the state as an integer.In practice systems are built up using design principles from the Open Telecom Platform which leads to more code upgradable designs. Successful hot code loading is a tricky subject, code needs to be written to make use of Erlang's facilities.DistributionErlang was released by Ericsson as open-source to ensure its independence from a single vendor and to increase awareness of the language. Distribution of the language together with libraries and the real-time distributed database Mnesia is the Open Telecom Platform (OTP). Ericsson and a few other companies offer commercial support for Erlang.Since it was released as open source in 1998 it has been used by several companies world-wide, including Nortel and T-Mobile “''The largest user of Erlang is (surprise!) Ericsson. Ericsson use it to write software used in telecommunications systems. Many (dozens) projects have used it, a particularly large one is the extremely scalable AXD301 ATM switch.''” Other commercial users listed as part of the FAQ include: Nortel, Deutsche Flugsicherung (the German national air traffic control organisation), and T-Mobile. It has been arguably considered as the next big languageI do not believe that other languages can catch up with Erlang anytime soon. It will be easy for them to add language features to be like Erlang. It will take a long time for them to build such a high-quality VM and the mature libraries for concurrency and reliability. So, Erlang is poised for success. If you want to build a multicore application in the next few years, you should look at Erlang.，as more and more organizations began to adopt it in important applications including Amazon SimpleDBhttp://www.satine.org/archives/2007/12/13/amazon-simpledb/&lt;/ref&gt;, Yahoo! Deliciousblog.socklabs.com/2008/09/erlang_is_delicious_cufp_slide , Facebook Chat systemhttp://www.facebook.com/note.php?note_id=16787213919&amp;id=9445547199&amp;index=2&lt;/ref&gt;, and so on., Erlang is under active development with regular releases. It is available for several Unix-like operating systems (including Mac OS X) and Microsoft Windows.See alsoejabberd, an XMPP instant messaging server written in Erlang that powers jabber.orgWings 3D, 3D modeller written in Erlang.Yaws (Yet Another Web Server), a web server written in Erlang.Tsung, a high-performance benchmarking tool written in Erlang.ErlLounge, Gatherings where Erlang is discussed.CouchDB, a document-based database written in Erlang.Facebook, the chat system is implemented using Erlang &lt;/ref&gt;Meetic, a French dating service uses ejabberd for its chat system.Scalaris, a scalable, fault-tolerant structured storage with transactions for global online services.Disco Project, Erlang implementation of the Map-Reduce framework for distributed computingRabbitMQ, Erlang implementation of Advanced Message Queuing Protocol (AMQP)NotesFurther readingJoe Armstrong (Pragmatic Bookshelf, 2007, ISBN 978-1-9343560-0-5). “Programming Erlang, Software for a Concurrent World”.Mattsson, H., Nilsson, H., Wikstrom, C.: “Mnesia - A distributed robust DBMS for telecommunications applications.” First International Workshop on Practical Aspects of Declarative Languages (PADL'99) (1999) pages 152-163J. Armstrong, R. Virding, C. Wikström, M. Williams (Prentice Hall, 1996, ISBN 0-13-508301-X) "Concurrent Programming in Erlang"Martin Logan, Eric Merritt, Richard Carlsson, and Robert Calco (Manning MEAP, 2008, ISBN: 1933988789) "Concurrent Programming with Erlang/OTP"External linksOpen Source Erlang websiteEricsson's Erlang websiteErlang eXchange conference websiteEarly history of Erlang (PDF) High-Performance Erlang websitetrapexit “Your Last Stop for Erlang Information”CEAN The Comprehensive Erlang Archive NetworkErlang Style ConcurrencyErlang: The Movie (google video) (high quality version)Network Programming in ErlangScalarisDisco ProjectRabbitMQCategory:Declarative programming languages Category:Functional languages Category:Concurrent programming languages * Category:Ericsson Category:Articles with example Erlang code Category:Virtual machinesca:Erlang cs:Erlang (programovací jazyk) da:Erlang (programmeringssprog) de:Erlang (Programmiersprache) es:Erlang fr:Erlang (langage) gl:Erlang ko:얼랑 (프로그래밍 언어) it:Erlang (linguaggio) nl:Erlang (programmeertaal) ja:Erlang pl:Erlang (język programowania) ru:Erlang sv:Erlang (programspråk) th:ภาษาเออร์แลง uk:Erlang zh:Erlang