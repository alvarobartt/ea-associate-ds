 | typing = dynamic (&quot;duck&quot;) | implementations = Ruby MRI, YARV, JRuby, Rubinius | influenced by = Smalltalk, Perl, Lisp, Scheme, Python, CLU, Eiffel, Ada, Dylan | influenced = Groovy, Perl 6 | operating system = Cross-platform | license = Ruby LicenseGNU General Public License | website = www.ruby-lang.org  Ruby is a dynamic, reflective, general purpose object-oriented programming language that combines syntax inspired by Perl with Smalltalk-like features. Ruby originated in Japan during the mid-1990s and was initially developed and designed by Yukihiro &quot;Matz&quot; Matsumoto.Ruby supports multiple programming paradigms, including functional, object oriented, imperative and reflection. It also has a dynamic type system and automatic memory management; it is therefore similar in varying respects to Python, Perl, Lisp, Dylan, and CLU.In its current, official implementation, written in C, Ruby is a single-pass interpreted language. There is currently no specification of the Ruby language, so the original implementation is considered to be the de facto reference. As of 2008, there are a number of complete or upcoming alternative implementations of the Ruby language, including YARV, JRuby, Rubinius, IronRuby, and MacRuby, each of which takes a different approach, with JRuby and IronRuby providing just-in-time compilation functionality.HistoryRuby was conceived on February 24 1993 by Yukihiro Matsumoto who wished to create a new language that balanced functional programming with imperative programming.http://www.ruby-lang.org/en/about/ Ruby-Lang About Ruby According to Matsumoto he "wanted a scripting language that was more powerful than Perl, and more object-oriented than Python. That's why I decided to design my own language".http://www.linuxdevcenter.com/pub/a/linux/2001/11/29/ruby.html An Interview with the Creator of RubyEtymology of the name &quot;Ruby&quot;The name "Ruby" was decided on during an online chat session between Matsumoto and Keiju Ishitsuka on February 24, 1993, before any code had been written for the language.http://blog.nicksieger.com/articles/2006/10/20/rubyconf-history-of-ruby History of Ruby Initially two names were proposed: "Coral" and "Ruby", with the latter the one being chosen as the name by Matsumoto in a later email to Ishitsuka.http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/88819 "historic The desicive moment of the language name Ruby. (Re: ANN ruby 1.8.1)" - Email from Hiroshi Sugihara to ruby-talk Matsumoto has later stated that a factor in choosing the name "Ruby" was because it was the birthstone of one of his colleagues.http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/394 "Re: the name of Ruby?" - Email from Yukihiro Matsumoto to ruby-talk Later it was recognized that pearl is the birthstone for the month of June, while ruby is the birthstone for July, implying Ruby as the successor of Perl.An Interview with the Creator of Rubyhttp://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/394 "Re: the name of Ruby?" - Email from Yukihiro Matsumoto to ruby-talkFirst publicationThe first public release of Ruby 0.95 was announced on Japanese domestic newsgroups on December 21, 1995.http://eigenclass.org/hiki/ruby+0.95 More archeolinguistics: unearthing proto-Rubyhttp://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-talk/382 "Re: history of ruby" - Email from Yukihiro Matsumoto to ruby-talk Subsequently three more versions of Ruby were released in two days.http://blog.nicksieger.com/articles/2006/10/20/rubyconf-history-of-ruby History of Ruby The release coincided with the launch of the Japanese language ruby-list mailing list which was the first mailing list for the new language.Already present at this stage of development were many of the features familiar in later releases of Ruby, including object oriented design, classes with inheritance, mixins, iterators, closures, exception handling, and garbage collection.http://blade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-list/124 "TUTORIAL - ruby's features" - Email From Yukihiro Matsumoto to ruby-listRuby 1.0Ruby reached version 1.0 on December 25, 1996.http://blog.nicksieger.com/articles/2006/10/20/rubyconf-history-of-ruby A History of RubyFollowing the release of Ruby 1.3 in 1999 the first English language mailing list ruby-talk began,http://www.linuxdevcenter.com/pub/a/linux/2001/11/29/ruby.html An Interview with the Creator of Ruby which signaled a growing interest in the language outside of Japan. In September 2000, the first English language book Programming Ruby was printed, which was later freely released to the public further widening the adoption of Ruby amongst native English speakers.Ruby 1.8.7As of June 2008, the latest stable version of the reference implementation is 1.8.7.PhilosophyThe language's creator, Yukihiro &quot;Matz&quot; Matsumoto, has said that Ruby is designed for programmer productivity and fun, following the principles of good user interface design.The Ruby Programming Language by Yukihiro Matsumoto on 2000-06-12 (informit.com) He stresses that systems design needs to emphasize human, rather than computer, needs The Philosophy of Ruby, A Conversation with Yukihiro Matsumoto, Part I by Bill Venners on 2003-09-29 (Artima Developer):Ruby is said to follow the principle of least surprise (POLS), meaning that the language should behave in such a way as to minimize confusion for experienced users. Matsumoto has said his primary design goal was to make a language which he himself enjoyed using, by minimizing programmer work and possible confusion. He has said he had not applied the principle of least surprise to the design of Ruby,The Philosophy of Ruby, A Conversation with Yukihiro Matsumoto, Part I by Bill Venners on 2003-09-29 (Artima Developer) but nevertheless the phrase has come to be closely associated with the Ruby programming language. The phrase has itself been a source of surprise, as novice users may take it to mean that Ruby's behaviors try to closely match behaviors familiar from other languages. In a May 2005 discussion on the comp.lang.ruby newsgroup, Matsumoto attempted to distance Ruby from POLS, explaining that because any design choice will be surprising to someone, he uses a personal standard in evaluating surprise. If that personal standard remains consistent there will be few surprises for those familiar with the standard.Ruby Weekly News 23rd - 29th May 2005&lt;!-- Bot generated title --&gt;Matsumoto defined it this way in an interviewThe Philosophy of Ruby&lt;!-- Bot generated title --&gt;: FeaturesObject-oriented, "everything is an object"Five levels of variable scope: global, class, instance, local, and blockException handlingIterators and closures (based on passing blocks of code)Native, Perl-like regular expressions at the language levelOperator overloadingAutomatic garbage collectingHighly portableCooperative multi-threading on all platforms using green threadsDLL/Shared library dynamic loading on most platformsIntrospection, reflection and metaprogrammingLarge standard librarySupports dependency injectionSupports object runtime alterationContinuations and generatorsRuby currently lacks full support for Unicode, though it has partial support for UTF-8.SemanticsRuby is object-oriented: every data type is an object, including classes and types which many other languages designate as primitives (such as integers, booleans, and "nil"). Every function is a method. Named values (variables) always designate references to objects, not the objects themselves. Ruby supports inheritance with dynamic dispatch, mixins and singleton methods (belonging to, and defined for, a single instance rather than being defined on the class). Though Ruby does not support multiple inheritance, classes can import modules as mixins. Procedural syntax is supported, but all methods defined outside of the scope of a particular object are actually methods of the Object class. Since this class is parent to every other class, the changes become visible to all classes and objects.Ruby has been described as a multi-paradigm programming language: it allows procedural programming (defining functions/variables outside classes makes them part of the root, 'self' Object), with object orientation (everything is an object) or functional programming (it has anonymous functions, closures, and continuations; statements all have values, and functions return the last evaluation). It has support for introspection, reflection and metaprogramming, as well as support for interpreter-basedGreen threads threads. Ruby features dynamic typing, and supports parametric polymorphism.According to the Ruby FAQ Ruby FAQ, "If you like Perl, you will like Ruby and be right at home with its syntax. If you like Smalltalk, you will like Ruby and be right at home with its semantics. If you like Python, you may or may not be put off by the huge difference in design philosophy between Python and Ruby/Perl." How Does Ruby Compare With Python? (FAQ)SyntaxThe syntax of Ruby is broadly similar to Perl and Python. Class and method definitions are signaled by keywords. In contrast to Perl, variables are not obligatorily prefixed with a sigil. When used, the sigil changes the semantics of scope of the variable. The most striking difference from C and Perl is that keywords are typically used to define logical code blocks, without braces (i.e., pair of ). For practical purposes there is no distinction between expressions and statementsIn Ruby's syntax, statement is just a special case of a expression which cannot appear as a argument (e.g. multiple assignment). http://ruby-talk.com/1120&lt;br /statement ... can not be part of expression unless grouped within parentheses. http://ruby-talk.com/2460 . Line breaks are significant and taken as the end of a statement; a semicolon may be equivalently used. Unlike Python, indentation is not significant.One of the differences of Ruby compared to Python and Perl is that Ruby keeps all of its instance variables completely private to the class and only exposes them through accessor methods (attr_writer, attr_reader, etc). Unlike the "getter" and "setter" methods of other languages like C++ or Java, accessor methods in Ruby can be written with a single line of code. As invocation of these methods does not require the use of parentheses, it is trivial to change an instance variable into a full function, without modifying a single line of code or having to do any refactoring achieving similar functionality to C# and VB.NET property members. Python's property descriptors are similar, but come with a tradeoff in the development process. If one begins in Python by using a publicly exposed instance variable and later changes the implementation to use a private instance variable exposed through a property descriptor, code internal to the class may need to be adjusted to use the private variable rather than the public property. Ruby removes this design decision by forcing all instance variables to be private, but also provides a simple way to declare set and get methods. This is in keeping with the idea that in Ruby, one never directly accesses the internal members of a class from outside of it. Rather one passes a message to the class and receives a response.See the examples section for samples of code demonstrating Ruby syntax.&quot;Gotchas&quot;Language comparisonSome features which differ notably from languages such as C or Perl:Names which begin with a capital letter are treated as constants, so local variables should begin with a lowercase letter.The sigils $ and @ do not indicate variable data type as in Perl, but rather function as scope resolution operators.To denote floating point numbers, one must follow with a zero digit (99.0) or an explicit conversion (99.to_f). It is insufficient to append a dot (99.), because numbers are susceptible to method syntax.Boolean evaluation of non-boolean data is strict: 0, "" and [] are all evaluated to true. In C, the expression 0 ? 1 : 0 evaluates to 0 (i.e. false). In Ruby, however, it yields 1, as all numbers evaluate to true; only nil and false evaluate to false. A corollary to this rule is that Ruby methods by convention &mdash; for example, regular-expression searches &mdash; return numbers, strings, lists, or other non-false values on success, but nil on failure (e.g., mismatch). This convention is also used in Smalltalk, where only the special objects true and false can be used in a boolean expression.Versions prior to 1.9 lack a character data type (compare to C, which provides type char for characters). This may cause surprises when slicing strings: "abc"0 yields 97 (an integer, representing the ASCII code of the first character in the string); to obtain "a" use "abc"0,1 (a substring of length 1) or "abc"0.chr.The notation statement until expression, unlike other languages' equivalent statements (e.g. do  while (not(expression)); in C/C++/...), actually never runs the statement if the expression is already true. This is because statement until expression is actually syntactic sugar over until expression; statement; end, the equivalent of which in C/C++ is while (not(expression)) statement; just like statement if expression is an equivalent to if expression; statement; end. However, the notation begin statement end until expression in Ruby will in fact run the statement once even in if the expression is already true.Because constants are references to objects, changing what a constant refers to generates a warning, but modifying the object itself does not. For example, Greeting  does not generate an error or warning. This is similar to final variables in Java, but Ruby does also have the functionality to "freeze" an object, unlike Java.Some features which differ notably from other languages:The usual operators for conditional expressions, and and or, do not follow the normal rules of precedence: and does not bind tighter than or. Ruby also has expression operators || and && which work as expected.Language featuresOmission of parentheses around method arguments may lead to unexpected results if the methods take multiple parameters. The Ruby developers have stated that omission of parentheses on multi-parameter methods may be disallowed in future Ruby versions; the current (Nov 2007) Ruby interpreter throws a warning which encourages the writer not to omit (), to avoid ambiguous meaning of code. Not using () is still common practice, and can be especially nice to use Ruby as a human readable domain-specific programming language itself, along with the method called method_missing().A list of "gotchas" may be found in Hal Fulton's book The Ruby Way, 2nd ed (ISBN 0-672-32884-4), Section 1.5. A similar list in the 1st edition pertained to an older version of Ruby (version 1.6), some problems of which have been fixed in the meantime. retry, for example, now works with while, until, and for, as well as iterators.Interaction The Ruby official distribution also includes "irb", an interactive command-line interpreter which can be used to test code quickly. The following code fragment represents a sample session using irb: $ irb irb(main):001:0 puts "Hello, World" Hello, World = nil irb(main):002:0 1+2 = 3 ExamplesThe following examples can be run in a Ruby shell such as Interactive Ruby Shell or saved in a file and run from the command line by typing ruby .Classic Hello world example: puts "Hello World!" Some basic Ruby code:Everything, including a literal, is an object, so this works:199.abs # 199"ruby is cool".length # 12 "Rick Astley".index("c") # 2 "Nice Day Isn't It?".downcase.split(//).sort.uniq.join # " '?acdeinsty" Conversions: puts "What's your favorite number?" number = gets.chomp outputnumber = number.to_i + 1 puts outputnumber.to_s + ' is a bigger and better favorite number.' StringsThere are a variety of methods of defining strings in RubyThe below conventions are equivalent for double quoted strings:  a = "\nThis is a double quoted string\n" a = %Q a = The below conventions are equivalent for single quoted strings:  a = 'This is a single quoted string' a = %qCollectionsConstructing and using an array: a = 3.14, 1, 2, [4, 5]p a2 # 3.14 p a.[](2) # 3.14 p a.reverse # [5, 2, 1, 3.14, 'hi', 1] p a.flatten.uniq # 'hi', 3.14, 2, 4, 5 Constructing and using an associative array: hash =  puts hash:fire # Prints: hothash.each_pair do |key, value| # Or: hash.each do |key, value| puts &quot;# is #&quot;endPrints: water is wetfire is hothash.delete :water # Deletes :water = 'wet' hash.delete_if  # Deletes :fire = 'hot' Blocks and iteratorsThe two syntaxes for creating a code block:  # Note the ordo puts "Hello, World!" end Parameter-passing a block to be a closure:In an object instance variable (denoted with '@'), remember a block.def remember(&a_block) @block = a_blockendInvoke the above method, giving it a block which takes a name.remember !"When the time is right (for the object) -- call the closure!@block.call("Jon")= "Hello, Jon!"Returning closures from a method: def create_set_and_get(initial_value=0) # Note the default value of 0 closure_value = initial_value
 return Proc.new , Proc.new endsetter, getter = create_set_and_get # ie. returns two values setter.call(21) getter.call # = 21 Yielding the flow of program control to a block which was provided at calling time: def use_hello yield &quot;hello&quot;endInvoke the above method, passing it a block.use_hello  # = 'hello' Iterating over enumerations and arrays using blocks: array = 'hi', 3.14 array.each = 1= 'hi'= 3.14array.each_index : #" = 0: 1= 1: 'hi'= 2: 3.14(3..6).each = 3= 4= 5= 6A method such as inject() can accept both a parameter and a block. Inject iterates over each member of a list, performing some function on while retaining an aggregate. This is analogous to the foldl function in functional programming languages. For example: 1,3,5.inject(10)  # = 19 On the first pass, the block receives 10 (the argument to inject) as sum, and 1 (the first element of the array) as element; this returns 11. 11 then becomes sum on the next pass, which is added to 3 to get 14. 14 is then added to 5, to finally return 19.Blocks work with many built-in methods: File.open('file.txt', 'w') do |file| # 'w' denotes "write mode". file.puts 'Wrote some text.'end # File is automatically closed hereFile.readlines('file.txt').each do |line| puts lineend= Wrote some text.Using an enumeration and a block to square the numbers 1 to 10: (1..10).collect  # = 4, 9, 16, 25, 36, 49, 64, 81, 100 ClassesThe following code defines a class named Person. In addition to 'initialize', the usual constructor to create new objects, it has two methods: one to override the  comparison operator (so Array#sort can sort by age) and the other to override the to_s method (so Kernel#puts can format its output). Here, "attr_reader" is an example of metaprogramming in Ruby: "attr_accessor" defines getter and setter methods of instance variables, "attr_reader" only getter methods. Also, the last evaluated statement in a method is its return value, allowing the omission of an explicit 'return'. class Person attr_reader :name, :age
 def initialize(name, age)
   @name, @age = name, age
 end
 def &lt;=&gt;(person) # Comparison operator for sorting
   @age &lt;=&gt; person.age
 end
 def to_s
   &quot;#@name (#@age)&quot;
 endendgroup = [ Person.new(&quot;Bob&quot;, 33), 
 Person.new(&quot;Chris&quot;, 16), 
 Person.new(&quot;Ash&quot;, 23) ]puts group.sort.reverse The above prints three names in reverse age order:  Bob (33) Ash (23) Chris (16) ExceptionsAn exception is raised with a raise call:  raise An optional message can be added to the exception:  raise "This is a message" You can also specify which type of exception you want to raise:  raise ArgumentError, "Illegal arguments!" Alternatively, you can pass an exception instance to the raise method:  raise ArgumentError.new( "Illegal arguments!" ) This last construct is useful when you need to raise a custom exception class featuring a constructor which takes more than one argument:  class ParseError Exceptions are handled by the rescue clause. Such a clause can catch exceptions which inherit from StandardError: beginDo somethingrescueHandle exceptionend It is a common mistake to attempt to catch all exceptions with a simple rescue clause. To catch all exceptions one must write: beginDo somethingrescue Exception # don't write just rescue -- that only catches StandardError, a subclass of ExceptionHandle exceptionend Or catch particular exceptions: begin...rescue RuntimeErrorhandlingend It is also possible to specify that the exception object be made available to the handler clause: begin...rescue RuntimeError = ehandling, possibly involving e, such as "print e.to_s"end Alternatively, the most recent exception is stored in the magic global $!.You can also catch several exceptions:  begin...rescue RuntimeError, Timeout::Error = ehandling, possibly involving eend Or catch an array of exceptions:  array_of_exceptions = Timeout::Error begin...rescue *array_of_exceptions = ehandling, possibly involving eend MetaprogrammingRuby provides a programmer the ability to add to or modify methods in the language's Standard Library during runtime, as well for a Ruby program to modify itself during its operation without generating source code, techniques known as metaprogramming. A simple example of adding a new method to the Standard Library's Time class:re-open Ruby's Time classclass Time def yesterday
   self - 86400
 endendtoday = Time.now # = Thu Aug 14 16:51:50 +1200 2008 yesterday = today.yesterday # = Wed Aug 13 16:51:50 +1200 2008 More examplesMore sample Ruby code is available as algorithms in the following articles:Exponentiating by squaringTrabb Pardo-Knuth algorithmImplementationsRuby has two main implementations: The official Ruby interpreter often referred to as the Matz's Ruby Interpreter or MRI, which is the most widely used, and JRuby, a Java-based implementation.There are other less known implementations such as IronRuby (pre-alpha sources available on August 31st, 2007), Rubinius, Ruby.NET, XRuby and YARV. YARV is Ruby 1.9's official new virtual machine and is no longer a separate project.The maturity of Ruby implementations tend to be measured by their ability to run Rails (because this is a complex framework to implement, and it uses a lot of Ruby-specific features). The point when a particular implementation achieves this goal is called The Rails singularity. As of May 2008, only the reference implementation (MRI) and JRuby are able to run Rails unmodified in a production environment. IronRuby and Rubinius start to be able to run Rails test cases, but they still are far from production ready for this task.As of Ruby MRI, Ruby is available on a lot of operating systems such as Linux, Mac OS X, Microsoft Windows, Windows CE and most flavors of Unix.CriticismAs variables are declared simply by assigning a value to them, typing errors can introduce new variables and cause unexpected behavior.What’s Wrong With Ruby?Being a dynamically typed language, errors can occur during the execution of the program if a variable were to be assigned a value of the wrong type. This is common to all dynamically typed languages, such as Lisp, JavaScript, and Python. In Ruby's case the interpreter would not catch the initial mis-assignment, but in most circumstances will throw an error if the mis-assigned variable is later treated as a type that it is not, as opposed to the silent type conversion of some languages.Ruby's ability for metaprogramming allows a programmer to modify methods in the language's Standard Library during runtime, a practice known as monkey patching. This can lead to possible collisions of behavior and subsequent unexpected results, and is a concern if done recklessly for code scalability. [http://avdi.org/devblog/2008/02/23/why-monkeypatching-is-destroying-ruby/ Monkeypatching is Destroying Ruby.The Ruby threading model uses green threads Ruby Threading - RubySpec&lt;!-- Bot generated title --&gt;, and its model has some inherent limitations which render it difficult to use or unsafe in some scenarios.Writing a standlone, threaded application using Ruby On Rails at KILLERSITES.COM&lt;!-- Bot generated title --&gt;Ruby 1.8 does not yet have native support for Unicode or multibyte strings,Headius: Unicode in Ruby, Unicode in JRuby?&lt;!-- Bot generated title --&gt; although 1.9 added multiple improvements in this area.Ruby suffers from backward compatibility problems.InfoQ: Ruby 1.9 released&lt;!-- Bot generated title --&gt;Ruby code runs slower than many compiled languages (as is typical for interpreted languages) and other major scripting languages such as Python and PerlThe Computer Language Benchmarks Game. However, in future releases (current revision: 1.9), Ruby will be bytecode compiled to be executed on YARV (Yet Another Ruby VM). The performance of YARV is currently very similar to those of other scripting languages such as Python.Ruby 2.0 aims to address some of the aforementioned problems:Native threads will be used instead of green threads.Gluttonous : YARV Progress Report&lt;!-- Bot generated title --&gt;Full support for Unicode strings.Some problems which may not be solved in version 2.0 include:Ruby still lacks a specification, the current C implementation being the de facto reference specification.Headius: What Would I (Will I?) Change About Ruby&lt;!-- Bot generated title --&gt;From Java to Ruby&lt;!-- Bot generated title --&gt; However the work for a specification is officially ongoing with a project named RubySpec based on the work started by the Rubinius project. RubySpec The creator of Ruby has expressed his plans to make Ruby an ISO standard, which he deems will take some time to be completed.RubyKaigi 2008: Standardization, 1.9 RoadmapRepositories and librariesThe Ruby Application Archive (RAA), as well as RubyForge, serve as repositories for a wide range of Ruby applications and libraries, containing more than seven thousand items. Although the number of applications available does not match the volume of material available in the Perl or Python community, there are a wide range of tools and utilities which serve to foster further development in the language.RubyGems has become the standard package manager for Ruby libraries. It is very similar in purpose to Perl's CPAN, although its usage is more like apt-get.See alsoDuck typingComparison of programming languagesWatirRuby MRI, the reference C implementationJRubyIronRubyRubiniusXRubyRamazeRuby on RailsReferencesExternal links Ruby language home pageRuby documentation siteRuby.on-page.net — the simplest Ruby manual with many samplesRuby programming language at the Open Directory ProjectRuby User Guide MirrorRuby From Other LanguagesWiki: Ruby language and implementation specificationWriting C Extensions to Ruby (MRI 1.8)RubyFlow: Community Filtered Ruby NewsCategory:Class-based programming languages Category:Dynamically-typed programming languages Category:Scripting languages Category:Curly bracket programming languages Category:Articles with example Ruby code Category:Ruby programming languagear:روبي (لغة برمجة) bn:রুবি (প্রোগ্রামিং ভাষা) bg:Ruby ca:Ruby cs:Ruby da:Ruby (programmeringssprog) de:Ruby (Programmiersprache) es:Ruby eo:Ruby (programlingvo) eu:Ruby fa:روبی fr:Ruby gl:Ruby ko:루비 (프로그래밍 언어) hr:Ruby (programski jezik) id:Ruby (bahasa pemrograman) ia:Ruby (linguage de programmation) it:Ruby he:Ruby ka:რუბი (პროგრამირების ენა) ku:روبی lt:Ruby hu:Ruby nl:Ruby (programmeertaal) ja:Ruby no:Ruby nn:Ruby pl:Ruby (język programowania) pt:Ruby (linguagem de programação) ro:Ruby ru:Ruby sr:Програмски језик Руби fi:Ruby sv:Ruby ta:ரூபி th:ภาษารูบี vi:Ruby (ngôn ngữ lập trình) tg:Руби tr:Ruby (programlama dili) uk:Ruby zh-yue:Ruby程式語言 bat-smg:Ruby zh:Ruby