In information theory and computer science, the Levenshtein distance is a metric for measuring the amount of difference between two sequences (i.e., the so called edit distance). The Levenshtein distance between two strings is given by the minimum number of operations needed to transform one string into the other, where an operation is an insertion, deletion, or substitution of a single character. A generalization of the Levenshtein distance (Damerau-Levenshtein distance) allows the transposition of two characters as an operation.The metric is named after Vladimir Levenshtein, who considered this distance in 1965.В.И. Левенштейн (1965) Двоичные коды с исправлением выпадений, вставок и замещений символов. Доклады Академий Наук СССР 163.4:845–848. Appeared in English as: V. I. Levenshtein, Binary codes capable of correcting deletions, insertions, and reversals. Soviet Physics Doklady 10 (1966):707–710. It is often used in applications that need to determine how similar, or different, two strings are, such as spell checkers.For example, the Levenshtein distance between "kitten" and "sitting" is 3, since the following three edits change one into the other, and there is no way to do it with fewer than three edits:kitten → sitten (substitution of 's' for 'k')sitten → sittin (substitution of 'i' for 'e')sittin → sitting (insert 'g' at the end).It can be considered a generalization of the Hamming distance, which is used for strings of the same length and only considers substitution edits.The algorithmA commonly-used bottom-up dynamic programming algorithm for computing the Levenshtein distance involves the use of an (n + 1) × (m + 1) matrix, where n and m are the lengths of the two strings. This algorithm is based on the Wagner-Fischer algorithm for edit distance. Here is pseudocode for a function LevenshteinDistance that takes two strings, s'' of length ''m, and t'' of length ''n, and computes the Levenshtein distance between them:'''int''' LevenshteinDistance('''char''' s[1..m], '''char''' t[1..n])
   ''// d is a table with m+1 rows and n+1 columns''
   '''declare''' '''int''' d[0..m, 0..n]   '''for''' i '''from''' 0 '''to''' m
       d[i, 0] := i
   '''for''' j '''from''' 0 '''to''' n
       d[0, j] := j   '''for''' i '''from''' 1 '''to''' m
       '''for''' j '''from''' 1 '''to''' n
       ''''''   '''return''' d[m, n]Two examples of the resulting matrix (the minimum steps to be taken are highlighted):kitten0123456s1substitution of 'k' for 's'|123456i22'i' equals 'i'|12345t332't' equals 't'|1234t4432't' equals 't'|123i55432substitution of 'e' for 'i'|23n665433'n' equals 'n'|2g776544insert 'g'|3|Saturday012345678S1'S' equals 'S'|0delete 'a'|1delete 't'|234567u2112'u' equals 'u'|23456n32223substitution of 'r' for 'n'|3456d433334'd' equals 'd'|345a5434444'a' equals 'a'|34y65445554'y' equals 'y'|3|The invariant maintained throughout the algorithm is that we can transform the initial segment s1..i into t1..j using a minimum of di,j operations. At the end, the bottom-right element of the array contains the answer.This algorithm is essentially part of a solution to the Longest common subsequence problem (LCS), in the particular case of 2 input lists.Proof of correctnessAs mentioned earlier, the invariant is that we can transform the initial segment s1..i into t1..j using a minimum of di,j operations. This invariant holds since:It is initially true on row and column 0 because s1..i can be transformed into the empty string t1..0 by simply dropping all i characters. Similarly, we can transform s1..0 to t1..j by simply adding all j characters.The minimum is taken over three distances, each of which is feasible:If we can transform s1..i to t1..j-1 in k operations, then we can simply add tj afterwards to get t1..j in k+1 operations.If we can transform s1..i-1 to t1..j in k operations, then we can do the same operations on s1..i and then remove the original si at the end in k+1 operations.If we can transform s1..i-1 to t1..j-1 in k operations, we can do the same to s1..i and then do a substitution of tj for the original si at the end if necessary, requiring k+cost operations.The operations required to transform s1..n into t1..m is of course the number required to transform all of s into all of t, and so dn,m holds our result.This proof fails to validate that the number placed in di,j is in fact minimal; this is more difficult to show, and involves an argument by contradiction in which we assume di,j is smaller than the minimum of the three, and use this to show one of the three is not minimal.Possible improvementsPossible improvements to this algorithm include:We can adapt the algorithm to use less space, ''O''(m'') instead of ''O(mn), since it only requires that the previous row and current row be stored at any one time.We can store the number of insertions, deletions, and substitutions separately, or even the positions at which they occur, which is always j.We can normalize the distance to the interval 0,1.If we are only interested in the distance if it is smaller than a threshold k'', then it suffices to compute a diagonal stripe of width ''2k+1 in the matrix. In this way, the algorithm can be run in ''O''(kl) time, where l is the length of the shortest string.Dan Gusfield. Algorithms on strings, trees, and sequences: computer science and computational biology. Cambridge University Press, New York, NY, USA, 1997.We can give different penalty costs to insertion, deletion and substitution. We can also give penalty costs that depend on which characters are inserted, deleted or substituted.The initialization of di,0 can be moved inside the main outer loop.By initializing the first row of the matrix with 0, the algorithm can be used for fuzzy string search of a string in a text Gonzalo Navarro. A guided tour to approximate string matching. ACM ComputingSurveys, 33(1):31–88, 2001.. This modification gives the end-position of matching substrings of the text. To determine the start-position of the matching substrings, the number of insertions and deletions can be stored separately and used to compute the start-position from the end-position Bruno Woltzenlogel Paleo. An approximate gazetteer for GATE based on levenshtein distance. Student Section of the European Summer School in Logic, Language and Information (ESSLLI), 2007.This algorithm parallelizes poorly, due to a large number of data dependencies. However, all the cost values can be computed in parallel, and the algorithm can be adapted to perform the minimum function in phases to eliminate dependencies.By examining diagonals instead of rows, and by using lazy evaluation, we can find the Levenshtein distance in O''(''m (1 + d'')) time (where ''d is the Levenshtein distance), which is much faster than the regular dynamic programming algorithm if the distance is small. L. Allison, Lazy Dynamic-Programming can be Eager. Inf. Proc. Letters 43(4) pp207-212, Sept' 1992 http://www.csse.monash.edu.au/~lloyd/tildeStrings/Alignment/92.IPL.html&lt;/ref&gt;Upper and lower boundsThe Levenshtein distance has several simple upper and lower bounds that are useful in applications which compute many of them and compare them. These include:It is always at least the difference of the sizes of the two strings.It is at most the length of the longer string.It is zero if and only if the strings are identical.If the strings are the same size, the Hamming distance is an upper bound on the Levenshtein distance.See also agrepBitap algorithmDamerau-Levenshtein distancediffDynamic time warpingFuzzy string searchingHamming distanceHamming weightJaccard indexJaro-Winkler distanceLevenshtein automatonLongest common subsequence problemLucene (an open source search engine that implements edit distance.)Manhattan distanceMetric spaceNeedleman-Wunsch algorithmSimilarity (mathematics)Similarity space on Numerical taxonomySmith-Waterman algorithmSørensen similarity indexReferencesExternal linksThe description of Levenshtein algorithmHighly optimized C# implementation (uses GNU's levenshtein.c as source and makes heavy use of C#'s pointer arithmetics capability)Java, C++ and VB implementations of the algorithmNIST's Dictionary of Algorithms and Data Structures: Levenshtein DistanceLevenshtein Distance visualizedInbuilt function in PHP, and example implementationContinuous variants, spike train metrics, and applications to neurophysiologyBWPGazetteer: an implementation of Levenshtein Distance in Java within the GATE (General Architecture for Text Engineering) framework for Natural Language Processing and Information Extraction.py-editdist: Python module implementation of Levenshtein Edit Distance between two strings.Category:Algorithms on strings Category:Discrete mathematics Category:String similarity measures Category:Dynamic programmingaf:Levenshteinafstand de:Levenshtein-Distanz es:Distancia de Levenshtein fr:Distance de Levenshtein it:Distanza di Levenshtein lv:Levenšteina attālums nl:Levenshteinafstand ja:レーベンシュタイン距離 nn:Levenshtein-distanse pl:Odległość Levenshteina pt:Distância Levenshtein ru:Расстояние Левенштейна sr:Левенштајново растојање fi:Levenšteinin etäisyys tg:Масофаи Левенштейн uk:Відстань Левенштейна vi:Khoảng cách Levenshtein zh:編輯距離