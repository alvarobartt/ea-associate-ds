 OpenGL ('Open G'raphics 'L'ibrary) is a standard specification defining a cross-language cross-platform API for writing applications that produce 2D and 3D computer graphics. The interface consists of over 250 different function calls which can be used to draw complex three-dimensional scenes from simple primitives. OpenGL was developed by Silicon Graphics Inc. (SGI) in 1992 and is widely used in CAD, virtual reality, scientific visualization, information visualization, and flight simulation. It is also used in video games, where it competes with Direct3D on Microsoft Windows platforms (see Direct3D vs. OpenGL). OpenGL is managed by the not-for-profit technology consortium, the Khronos Group, Inc.SpecificationAt its most basic level OpenGL is a specification, meaning it is simply a document that describes a set of functions and the precise behaviours that they must perform. From this specification, hardware vendors create implementations &mdash; libraries of functions created to match the functions stated in the OpenGL specification, making use of hardware acceleration where possible. Hardware vendors have to meet specific tests to be able to qualify their implementation as an OpenGL implementation.Efficient vendor-supplied implementations of OpenGL (making use of graphics acceleration hardware to a greater or lesser extent) exist for Mac OS, Microsoft Windows, Linux and many Unix platforms. Various software implementations exist, bringing OpenGL to a variety of platforms that do not have vendor support. Notably, the free software/open source library Mesa 3D is a fully software-based graphics API which is code-compatible with OpenGL. However to avoid licensing costs associated with formally calling itself an OpenGL implementation, it claims merely to be a "very similar" API. On some platforms, notably mobile phones, handhelds and game consoles, a reduced API OpenGL ES is often used.The OpenGL specification was revised by OpenGL Architecture Review Board (ARB) founded in 1992. The ARB was formed by a set of companies interested in the creation of a consistent and widely available API. Microsoft, one of the founding members, left the project in 2003.On 21 September 2006, control of OpenGL passed to the Khronos Group. This was done in order to improve the marketing of OpenGL, and to remove barriers between the development of OpenGL and OpenGL ES. The subgroup of Khronos that manages OpenGL was called the OpenGL ARB Working Group, for historical reasons. There is a list of members which make up the OpenGL ARB Working Group at section Members of Khronos Group. OpenGL is a general purpose API with lots of different possibilities because of the great number of companies with different interests which have made up the old ARB as well the current group.Mark Segal and Kurt Akeley authored the original OpenGL specification. Chris Frazier edited version 1.1. Jon Leech edited versions 1.2 through the present version 3.0. Jon Leech has retired as secretary of the old ARB, and Barthold Lichtenbelt has taken his place as Khronos OpenGL ARB Steering Group Chair .DesignOpenGL serves two main purposes:To hide the complexities of interfacing with different 3D accelerators, by presenting the programmer with a single, uniform API.To hide the differing capabilities of hardware platforms, by requiring that all implementations support the full OpenGL feature set (using software emulation if necessary).OpenGL's basic operation is to accept primitives such as points, lines and polygons, and convert them into pixels. This is done by a graphics pipeline known as the OpenGL state machine. Most OpenGL commands either issue primitives to the graphics pipeline, or configure how the pipeline processes these primitives. Prior to the introduction of OpenGL 2.0, each stage of the pipeline performed a fixed function and was configurable only within tight limits. OpenGL 2.0 offers several stages that are fully programmable using GLSL.OpenGL is a low-level, procedural API, requiring the programmer to dictate the exact steps required to render a scene. This contrasts with descriptive (aka scene graph or retained mode) APIs, where a programmer only needs to describe a scene and can let the library manage the details of rendering it. OpenGL's low-level design requires programmers to have a good knowledge of the graphics pipeline, but also gives a certain amount of freedom to implement novel rendering algorithms.OpenGL has historically been influential on the development of 3D accelerators, promoting a base level of functionality that is now common in consumer-level hardware:Rasterised points, lines and polygons as basic primitivesA transform and lighting pipelineZ-bufferingTexture mappingAlpha blendingA brief description of the process in the graphics pipeline could be:Evaluation, if necessary, of the polynomial functions which define certain inputs, like NURBS surfaces, approximating curves and the surface geometry.Vertex operations, transforming and lighting them depending on their material. Also clipping non visible parts of the scene in order to produce the viewing volume.Rasterisation or conversion of the previous information into pixels. The polygons are represented by the appropriate colour by means of interpolation algorithms.Per-fragment operations, like updating values depending on incoming and previously stored depth values, or colour combinations, among others.Lastly, fragments are inserted into the Frame buffer.Many modern 3D accelerators provide functionality far above this baseline, but these new features are generally enhancements of this basic pipeline rather than radical revisions of it.ExampleThis example will draw a green square on the screen. OpenGL has several ways to accomplish this task, but this is the easiest to understand. glClear( GL_COLOR_BUFFER_BIT ); This statement clears the color buffer, so that the screen will start blank. glMatrixMode( GL_PROJECTION ); /* Subsequent matrix commands will affect the projection matrix */ glLoadIdentity(); /* Initialise the projection matrix to identity */ glFrustum( -1, 1, -1, 1, 1, 1000 ); /* Apply a perspective-projection matrix */ These statements initialize the projection matrix, setting a 3d frustum matrix that represents the viewable area. This matrix transforms objects from camera-relative space to OpenGL's projection space. glMatrixMode( GL_MODELVIEW ); /* Subsequent matrix commands will affect the modelview matrix */ glLoadIdentity(); /* Initialise the modelview to identity */ glTranslatef( 0, 0, -3 ); /* Translate the modelview 3 units along the Z axis */ These statements initialize the modelview matrix. This matrix defines a transform from model-relative coordinates to camera space. The combination of the modelview matrix and the projection matrix transforms objects from model-relative space to projection screen space. glBegin( GL_POLYGON ); /* Begin issuing a polygon */ glColor3f( 0, 1, 0 ); /* Set the current color to green */ glVertex3f( -1, -1, 0 ); /* Issue a vertex */ glVertex3f( -1, 1, 0 ); /* Issue a vertex */ glVertex3f( 1, 1, 0 ); /* Issue a vertex */ glVertex3f( 1, -1, 0 ); /* Issue a vertex */ glEnd(); /* Finish issuing the polygon */ These commands draw a green square in the XY plane.DocumentationOpenGL's popularity is partially due to the excellence of its official documentation. The OpenGL ARB released a series of manuals along with the specification which have been updated to track changes in the API. These are almost universally known by the colors of their covers:The Red Book – OpenGL Programming Guide, 6th edition. ISBN 0-321-48100-3A readable tutorial and reference book – this is a 'must have' book for OpenGL programmers. The first edition is available online here and here.The Blue Book – OpenGL Reference manual, 4th edition. ISBN 0-321-17383-XEssentially a hard-copy printout of the man pages for OpenGL.Includes a poster-sized fold-out diagram showing the structure of an idealised OpenGL implementation. It is available here.The Green Book – OpenGL Programming for the X Window System. ISBN 0-201-48359-9A book about X11 interfacing and GLUT.The Alpha Book (which actually has a white cover) – OpenGL Programming for Windows 95 and Windows NT. ISBN 0-201-40709-4A book about interfacing OpenGL with Microsoft Windows.Then, for OpenGL 2.0 and beyond:The Orange Book – OpenGL Shading Language, 2nd edition. ISBN 0-321-33489-2A readable tutorial and reference book for GLSL.ExtensionsThe OpenGL standard allows individual vendors to provide additional functionality through extensions as new technology is created. Extensions may introduce new functions and new constants, and may relax or remove restrictions on existing OpenGL functions. Each vendor has an alphabetic abbreviation that is used in naming their new functions and constants. For example, NVIDIA's abbreviation (NV) is used in defining their proprietary function glCombinerParameterfvNV() and their constant GL_NORMAL_MAP_NV.It may happen that more than one vendor agrees to implement the same extended functionality. In that case, the abbreviation EXT is used. It may further happen that the Architecture Review Board "blesses" the extension. It then becomes known as a standard extension, and the abbreviation ARB is used. The first ARB extension was GL_ARB_multitexture, introduced in version 1.2.1. Following the official extension promotion path, multitexturing is no longer an optionally implemented ARB extension, but has been a part of the OpenGL core API since version 1.3.Before using an extension a program must first determine its availability, and then obtain pointers to any new functions the extension defines. The mechanism for doing this is platform-specific and libraries such as GLEW and GLEE exist to simplify the process.Specifications for nearly all extensions can be found at the official extension registry. http://www.opengl.org/registry/&lt;/ref&gt;Associated utility librariesSeveral libraries are built on top of or beside OpenGL to provide features not available in OpenGL itself. Libraries such as GLU can always be found with OpenGL implementations, and others such as GLUT and SDL have grown over time and provide rudimentary cross platform windowing and mouse functionality and if unavailable can easily be downloaded and added to a development environment. Simple graphical user interface functionality can be found in libraries like GLUI or FLTK. Still other libraries like AUX are deprecated and have been superseded by functionality commonly available in more popular libraries, but code using them still exists, particularly in simple tutorials. Other libraries have been created to provide OpenGL application developers a simple means of managing OpenGL extensions and versioning. Examples of these libraries include GLEW (the OpenGL Extension Wrangler Library) and GLEE (the OpenGL Easy Extension Library).In addition to the aforementioned simple libraries, other higher level object oriented scene graph retained mode libraries exist such as PLIB, OpenSG, OpenSceneGraph, and OpenGL Performer. These are available as cross platform free/open source or proprietary programming interfaces written on top of OpenGL and systems libraries to enable the creation of real-time visual simulation applications. Other solutions support parallel OpenGL programs for Virtual Reality, scalability or graphics clusters usage, either transparently like Chromium or through a programming interface like Equalizer.Mesa 3D is a free/open source implementation of OpenGL. It supports pure software rendering as well as providing hardware acceleration for several 3D graphics cards under Linux. As of June 22 2007 it implements the 2.1 standard, and provides some of its own extensions for some platforms.BindingsIn order to emphasize its multi-language and multi-platform characteristics, various bindings and ports have been developed for OpenGL in many languages. Some languages and their bindings are:Ada: Ada OpenGL 1.1 supports GL, GLU and GLUTBlitzMax: OOP language with no runtime. Supports Win32/64, Linux, Mac OS X (PowerPC/Intel). Built in OpenGL support.C#: The framework Tao for Microsoft .NET includes OpenGL between other multimedia librarieshttp://www.taoframework.com/&lt;/ref&gt;D: See bindings and Project DerelictDelphi: DotEiffel: EiffelOpenGLFortran: f90gl supports OpenGL 1.2, GLU 1.2 and GLUT 3.7FreeBASIC: Native OpenGL support. Built-in OpenGL context creation.Haskell: HOpenGL supports GL, GLU and GLUT. Included with the latest version of the Glasgow Haskell Compiler.Java:Java Bindings for OpenGL (JSR 231) and Java OpenGL (JOGL)Lightweight Java Game Library (LWJGL)Lisp: See the cl-opengl project at common-lisp.netMercury Prolog mtoglOcaml: GLCaml and LablGLPerl:Perl OpenGL (POGL) module - shared libs written in CC vs Perl and Perl vs Python benchmarksPike: It has a OpenGL native interface. Moreover, it supports GLU and GLUT http://pike.ida.liu.se/about/pike/modules.xml&lt;/ref&gt;PHP: See http://phpopengl.sourceforge.net/PureBasic: Native OpenGL support.Python: PyOpenGL supports GL, GLU and GLUTRuby: ruby-opengl - supports GL, GLU and GLUTScheme:Chicken Scheme has an OpenGL eggOpenGL bindings for PLT SchemeOpenGL bindings for Gauche SchemeYpsilon Scheme comes with GL and GLUT bindings out of the boxSmalltalk as seen in Croquet Project running on Squeak SmalltalkthinBasic - native interface for OpenGL 2.1, GLU library + language specific higher level moduleVisual Basic: ActiveX ControlVisual Prolog commercial editionFor more information on OpenGL Language bindings, see opengl.org's Wiki.Higher level functionalityOpenGL was designed to be graphic output-only: it provides only rendering functions. The core API has no concept of windowing systems, audio, printing to the screen, keyboard/mouse or other input devices. While this seems restrictive at first, it allows the code that does the rendering to be completely independent of the operating system it is running on, allowing cross-platform development. However some integration with the native windowing system is required to allow clean interaction with the host system. This is performed through the following add-on APIs:GLX – X11 (including network transparency)WGL – Microsoft WindowsCGL – Mac OS X. Better integration with Mac OS X's application frameworks is provided by APIs layered on top of CGL: AGL for Carbon and NSOpenGL for Cocoa.Additionally, GLUT, SDL and the GLFW libraries provide functionality for basic windowing using OpenGL, in a portable manner. More some opensource crossplatform toolkit like GTK+, QT and WxWidgets, include a widget to embed OpenGL contents.HistoryIn the 1980s, developing software that could function with a wide range of graphics hardware was a real challenge. Software developers wrote custom interfaces and drivers for each piece of hardware. This was expensive and resulted in much duplication of effort.By the early 1990s, Silicon Graphics (SGI) was a leader in 3D graphics for workstations. Their IRIS GL API was considered the state of the art and became the de facto industry standard, overshadowing the open standards-based PHIGS. This was because IRIS GL was considered easier to use, and because it supported immediate mode rendering. By contrast, PHIGS was considered difficult to use and outdated in terms of functionality.SGI's competitors (including Sun Microsystems, Hewlett-Packard and IBM) were also able to bring to market 3D hardware, supported by extensions made to the PHIGS standard. This in turn caused SGI market share to weaken as more 3D graphics hardware suppliers entered the market. In an effort to influence the market, SGI decided to turn the IrisGL API into an open standard.SGI considered that the IrisGL API itself wasn't suitable for opening due to licensing and patent issues. Also, the IrisGL had API functions that were not relevant to 3D graphics. For example, it included a windowing, keyboard and mouse API, in part because it was developed before the X Window System and Sun's NeWS systems were developed.In addition, SGI had a large number of software customers; by changing to the OpenGL API they planned to keep their customers locked onto SGI (and IBM) hardware for a few years while market support for OpenGL matured. Meanwhile, SGI would continue to try to maintain their customers tied to SGI hardware by developing the advanced and proprietary Iris Inventor and Iris Performer programming APIs.As a result, SGI released the OpenGL standard.The OpenGL standardised access to hardware, and pushed the development responsibility of hardware interface programs, sometimes called device drivers, to hardware manufacturers and delegated windowing functions to the underlying operating system. With so many different kinds of graphic hardware, getting them all to speak the same language in this way had a remarkable impact by giving software developers a higher level platform for 3D-software development.In 1992, SGI led the creation of the OpenGL architectural review board (OpenGL ARB), the group of companies that would maintain and expand the OpenGL specification for years to come. OpenGL evolved from (and is very similar in style to) SGI's earlier 3D interface, IrisGL. One of the restrictions of IrisGL was that it only provided access to features supported by the underlying hardware. If the graphics hardware did not support a feature, then the application could not use it. OpenGL overcame this problem by providing support in software for features unsupported by hardware, allowing applications to use advanced graphics on relatively low-powered systems.In 1994 SGI played with the idea of releasing something called "OpenGL++" which included elements such as a scene-graph API (presumably based around their Performer technology). The specification was circulated among a few interested parties – but never turned into a product.Microsoft released Direct3D in 1995, which would become the main competitor of OpenGL. On 17 December, 1997, Microsoft and SGI initiated the Fahrenheit project, which was a joint effort with the goal of unifying the OpenGL and Direct3D interfaces (and adding a scene-graph API too). In 1998 Hewlett-Packard joined the project. It initially showed some promise of bringing order to the world of interactive 3D computer graphics APIs, but on account of financial constraints at SGI, strategic reasons at Microsoft, and general lack of industry support, it was abandoned in 1999.OpenGL 2.0OpenGL 2.0 was conceived by 3Dlabs to address concerns that OpenGL was stagnating and lacked a strong direction. 3Dlabs proposed a number of major additions to the standard. Most of these were, at the time, rejected by the ARB or otherwise never came to fruition in the form that 3Dlabs proposed. However, their proposal for a C-style shading language was eventually completed, resulting in the current formulation of GLSL (the Open'GL' 'S'hading 'L'anguage, also 'sl'ang). Like the assembly-like shading languages that it was replacing, it allowed the programmer to replace the fixed-function vertex and fragment pipe with shaders, though this time written in a C-like language.The design of GLSL was notable for making relatively few concessions to the limitations of the hardware then available; this hearkened back to the earlier tradition of OpenGL setting an ambitious, forward-looking target for 3D accelerators rather than merely tracking the state of currently available hardware. The final OpenGL 2.0 specification http://www.opengl.org/documentation/specs/version2.0/glspec20.pdf&lt;/ref&gt; includes support for GLSL.OpenGL 2.1OpenGL 2.1 was released on August 2 2006 and is backward compatible with all prior OpenGL versions. OpenGL 2.1 incorporates the following functionality:OpenGL Shading Language revision 1.20 (GLSL)Commands to specify and query non-square matrix uniforms for use with the OpenGL Shading LanguagePixel buffer objects for efficient image transfers to and from buffer objects for commands such as glTexImage2D and glReadPixels.This functionality corresponds to the ARB_pixel_buffer_object extension.sRGB texture formats.This functionality corresponds to the EXT_texture_sRGB extension.OpenGL 3.0The newest revision of the OpenGL API is OpenGL 3.0http://www.opengl.org/registry/doc/glspec30.20080811.pdf&lt;/ref&gt;, released August 11, 2008 and is backward compatible with all prior OpenGL versions, though a deprecation mechanism has been introduced to simplify the API in future revisions.OpenGL Shading Language revision 1.30 (GLSL)Vertex Array ObjectsMore flexible Framebuffer Objects32-bit (single precision) floating-point textures and render buffers16-bit (half precision) floating-point vertex and pixel dataAbility to render vertex transformations into a bufferTexture arrays32-bit (single precision) floating point depth buffer supportFull use of OpenGL 3.0 is only available on DirectX 10 level hardwareLongs Peak and OpenGL 3.0 ControversyPrior to the release of OpenGL 3.0 the new revision was known as the codename Longs Peak. At the time of its original announcement Longs Peak was presented as the first major API revision in OpenGL's lifetime. It consisted of an overhaul to the way that OpenGL works, calling for fundamental changes to the API.The draft introduced a change to object management. The GL 2.1 object model was built upon the state-based design of OpenGL. That is, in order to modify an object or to use it, one needs to bind the object to the state system, then make modifications to the state or perform function calls that use the bound object.Because of OpenGL's use of a state system, objects must be mutable. That is, the basic structure of an object can change at any time, even if the rendering pipeline is asynchronously using that object. A texture object can be redefined from 2D to 3D. This requires any OpenGL implementations to add a degree of complexity to internal object management.Under the Longs Peak API object creation would become atomic, using templates to define the properties of an object which would be created with a single function call. The object could then be used immediately across multiple threads. Objects would also be immutable; however, they could have their contents changed and updated. For example, a texture could change its image, but its size and format could not be changed.To support backwards compatibility the old state based API would still be available, but no new functionality would be exposed via the old API in later versions of OpenGL. This would have allowed legacy code bases, such as the majority of CAD products, to continue to run while other software could be written against or ported to the new API.Longs Peak was initially due to be finalized in September 2007 under the name OpenGL 3.0, but the Khronos group announced October 30 that it had run into several issues that it wished to address before releasing the specification. As a result the spec was delayed, and the Khronos group went into a media blackout until the release of the final OpenGL 3.0 spec.The final specification proved far less revolutionary than the Longs Peak proposal. Instead of removing all immediate mode and fixed functionality (non-shader mode), the spec included them as deprecated features. The proposed object model was not included, and no plans have been announced to include it in any future revisions. As a result the API remained largely the same with a few existing extensions being promoted to core functionality.Amongst some developer groups this decision caused something of an uproar http://tech.slashdot.org/article.pl?sid=08/08/11/2135259&lt;/ref&gt;, with many developers professing that they would switch to DirectX in protest. Most complaints revolved around the lack of communication by Khronos to the development community and multiple features being discarded that were viewed favorably by many. Other frustrations included the requirement of DirectX 10 level hardware in order to use OpenGL 3.0 and the absence of geometry shaders and instanced rendering as a core features.Other sources reported that the community reaction wasn't quite as severe as originally presented http://feeds.feedburner.com/~r/opengl/zOLP/~3/365627409/&lt;/ref&gt;, with many vendors showing support for the update. http://feeds.feedburner.com/~r/opengl/zOLP/~3/368325680/&lt;/ref&gt; http://feeds.feedburner.com/~r/opengl/zOLP/~3/364953172/&lt;/ref&gt;Post OpenGL 3.0Prior to the release of OpenGL 3.0 plans were discussed to add more functionality to OpenGL beyond 3.0. However, since much of this discussion took place in the context of a redesigned API, and some of the features planned for the future releases are already in the final 3.0 spec, it is presently unclear what role (if any) the planned extensions will play moving forward.Longs Peak ReloadedThis revision, which was due to be released 2-3 months after 3.0, would have entailed adding smaller features to 3.0 that could not be added in the timeframe for its release. It was mostly ease-of-use features to make the API more convenient to use, in addition to a few features for performance purposes.Mt EvansThis revision, which was due to be released 3-5 months after 3.0, would bring OpenGL 3.0 up-to-date with more modern hardware features. These included geometry shaders, integers in shaders, texture arrays, and instanced rendering. However, it is worth noting that both the use of integers in shaders and texture arrays are already part of the final 3.0 spec.Members of Khronos GroupIn 2006, some of the OpenGL ARB Working Group members were:Advanced Micro Devices (AMD acquired ATI)AppleCreative LabsGraphic Remedyid SoftwareIntel CorporationNVIDIASony Computer EntertainmentSun MicrosystemsTexas InstrumentsFor a complete and updated list of the project's members see the promoters, contributors and academics member list of the Khronos Group.Sample renderings  Image:JOGL Refrection Demo Screenshot.png|Refraction using programmable vertex shaders Image:Perl OpenGL fob2.jpg|Animated textures using framebuffer objects and vertex/fragment program extensions  OpenGL GamesSome notable games that include an OpenGL renderer:18 Wheels of Steel - Euro Truck Sim also includes a DirectX RendererAmerica's Army (Only linux version)Baldur's Gate 2 – Defaults to D3DBZFlagCall of DutyCity of HeroesCity of VillainsCodeRED: Alien ArenaCounter-StrikeDarwinia - Defaults to D3DDoom 3Dwarf FortressEarth 2150EDuke32Enemy Territory: Quake WarsFar Cry – Defaults to D3DFrets On FireFlightGearHalf-Life 1HitmanHomeworld 2IL-2 Sturmovik: 1946Neverball and NeverputtNeverwinter NightsNexuizPenumbra: OverturePreyQuake seriesRageRuneScape - Uses the Java OpenGL developed by Kenneth Bradley Russell and Christopher John Kline.RuneScape HDSavage: The Battle for NewerthScorched 3DSecond LifeSerious SamSerious Sam 2 – Defaults to D3DSoldier of Fortune seriesSpringStarsiege: TribesStar Wars Jedi Knight: Jedi AcademyStar Wars Jedi Knight II: Jedi OutcastStar Wars: Knights of the Old RepublicThe Chronicles of Riddick: Escape from Butcher BayTrainzTribes 2Tux RacerWarcraft 3 - Defaults to D3D in WindowsWolfenstein: Enemy TerritoryWorld of Warcraft - Defaults to D3D in WindowsWurm OnlineUnreal GoldUnreal TournamentX-PlaneOpenGL applicationsSome notable opensource crossplatform applications that include an OpenGL renderer:Blender - 3D CAD, animation, and games engine.Scilab - Mathematical tool, clone of MATLABSome notable applications that include an OpenGL renderer:Adobe Premiere Pro - a real-time, timeline based video editing software applicationAdobe After Effects - a digital motion graphics and compositing softwareSee alsoARB (GPU assembly language) - OpenGL's low-level shading languageCg – Nvidia's shading language that works with OpenGLGLSL - Open crossplatform high-level shading language that works with OpenGLOpenCL - Open crossplatform GPU general purpose language that works with OpenGLOpenGL ES – OpenGL for embedded systemsOpenAL – The Open Audio Library – designed to work well with OpenGL.OpenSL ES – Another audio library.Graphics pipelineOpenGL support librariesGLUT – The OpenGL utility toolkit.SDL – The Simple DirectMedia Layer.GLU – Some additional functions for OpenGL programs.GLee - The OpenGL Easy Extension library.GLEW – The OpenGL Extension Wrangler Library.GLUI - a GUI toolkit made with GLUTGLFW - a portable framework for OpenGL application development.Framebuffer Object - an off-screen rendering extension.GLM - C++ mathematics toolkit for OpenGL based on GLSL specification.SFML - Simple and Fast Multimedia Library.Glux - The OpenGL Utility & Auxiliary Library.Other 3D graphics APIsMesa 3D – An open source implementation of OpenGL.Direct3D – A competitor to OpenGL. See Comparison of OpenGL and Direct3D.VirtualGL - An OpenGL 3D model server that send rendered images to a remote X serverOther 2D graphics APIsCairo (graphics) - a cross platform graphical vectorial draw and text toolkit.GTK+ - a cross platform graphical widget toolkit.Qt - a cross platform graphical widget toolkit.wxWidgets - a cross platform graphical widget toolkit.All can incorporate OpenGL 3D object. Cairo can use OpenGL as backend.BenchmarksGLMarkReferencesFurther readingRichard S. Wright, Benjamin Lipchak, Nicholas Haemel: OpenGL SuperBible: Comprehensive Tutorial and Reference, 4th Edition, Addison-Wesley, June 18 2007, ISBN 0-321-49882-8Dave Shreiner, Mason Woo, Jackie Neider, Tom Davis: OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 2.1, 6th Edition, Addison-Wesley, July 30 2007, ISBN 0-321-48100-3Fosner, Ron: OpenGL Programming for Windows 95 and Windows NT, Addison Wesley, ISBN 0-201-40709-4Kilgard, Mark: OpenGL for the X Window System, Addison-Wesley, ISBN 0-201-48359-9Lengyel, Eric: The OpenGL Extensions Guide, Charles River Media, ISBN 1-58450-294-0OpenGL Architecture Review Board, et al: OpenGL Reference Manual: The Official Reference Document to OpenGL, Version 1.4, Addison-Wesley, ISBN 0-321-17383-XOpenGL Architecture Review Board, et al: OpenGL Programming Guide: The Official Guide to Learning OpenGL, Version 2, Fifth Edition, Addison-Wesley, ISBN 0-321-33573-2Rost, Randi J.: OpenGL Shading Language, Addison-Wesley, ISBN 0-321-19789-5External linksOfficial websiteSGI's OpenGL websiteKhronos Group, Inc.NeHe Tutorials, OpenGL tutorialsCodeSampler.com, OpenGL Code SamplesgameBoX Linux - OpenGL (ES) demos and examplesOpenGL WikiOpenGL Discussion ForumsFahrenheit in MicrosoftOpenGL Programming Guide on the webgDEBugger - OpenGL Debugger and Profiler Windows and LinuxOpenGL and Glut tutorialsOpenGL Game Development Video TutorialsCategory:Graphics libraries Category:3D computer graphics Category:Application programming interfaces Category:Video game development Category:Graphics standards Category:Virtual reality Category:Cross-platform softwarear:مكتبة الرسوميات المفتوحة bn:ওপেনজিএল bs:OpenGL bg:OpenGL ca:OpenGL cs:OpenGL da:OpenGL de:OpenGL es:OpenGL fa:اپن‌جی‌ال fr:OpenGL gl:OpenGL ko:OpenGL it:OpenGL he:OpenGL ka:OpenGL lv:OpenGL hu:OpenGL nl:OpenGL ja:OpenGL no:OpenGL pl:OpenGL pt:OpenGL ro:OpenGL ru:OpenGL simple:OpenGL sk:OpenGL sl:OpenGL sr:OpenGL fi:OpenGL sv:OpenGL th:โอเพนจีแอล vi:OpenGL tr:OpenGL uk:OpenGL zh:OpenGL