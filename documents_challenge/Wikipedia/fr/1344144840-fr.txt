 La distance de Levenshtein mesure la similarité entre deux chaînes de caractères. Elle est égale au nombre minimal de caractères qu'il faut supprimer, insérer, ou remplacer pour passer d’une chaîne à l’autre.Son nom provient de Vladimir Levenshtein qui l'a définie en 1965. Elle est aussi connue sous le nom de distance d'édition ou encore de déformation dynamique temporelle, notamment en reconnaissance de la parole.Cette distance est d'autant plus grande que le nombre de différences entre les deux chaînes est grand. La distance de Levenshtein peut être considérée comme une généralisation de la distance de Hamming. On peut montrer en particulier que la distance de Hamming est un majorant de la distance de Levenshtein.DéfinitionOn appelle distance de Levenshtein entre deux mots M et P le coût minimal pour aller de M à P en effectuant les opérations élémentaires suivantes:substitution d'un caractère de M en un caractère de P.ajout dans M d'un caractère de P.suppression d'un caractère de M.On associe ainsi à chacune de ces opérations un coût. Par exemple, dans les exemples suivants, le coût est toujours égal à 1, sauf dans le cas d'une substitution de caractères identiques.ExemplesSi M = « examen » et P = « examen », alors LD (M, P) = 0, parce qu'aucune opération n'a été réalisée.Si M = « exam'e'''n » et P = « exam'a'n », alors LD (M, P) = 1, parce qu’il y a eu un remplacement (changement du ''e en a).Algorithme de LevenshteinL'algorithme ci-dessous permet de calculer la distance de Levenshtein entre deux chaines de caractères courtes. Pour des chaînes de caractères plus longues (plusieurs mots) il faut utiliser les algorithmes de Jaccard ou TF/IDF par exemple. L'algorithme de Levenshtein est un algorithme de programmation dynamique (solution de type du bas en haut), qui utilise une matrice de dimension (n + 1) × (m + 1) où n et m sont les dimensions des deux chaînes de caractères. Dans le pseudo-code suivant, la chaîne chaine1 est de longueur longueurChaine1 et chaine2, de longueur longueurChaine2. Cet algorithme renvoie un entier positif ou nul. Il renvoie 0 si les chaînes 1 et 2 sont égales. Si les chaînes 1 et 2 sont très différentes, la fonction renverra au maximum la plus grande longueur des deux chaînes.'''entier''' DistanceDeLevenshtein('''caractere''' chaine1[1..longueurChaine1], '''caractere''' chaine2[1..longueurChaine2])
   ''// d est un tableau de longueurChaine1+1 rangées et longueurChaine2+1 colonnes''
   '''declarer''' '''entier''' d[0..longueurChaine1, 0..longueurChaine2]
   ''// i et j itèrent sur chaine1 et chaine2''
   '''declarer''' '''entier''' i, j, coût   '''pour''' i '''de''' 0 '''à''' longueurChaine1
       d[i, 0] := i
   '''pour''' j '''de''' 0 '''à''' longueurChaine2
       d[0, j] := j   '''pour''' i '''de''' 1 '''à''' longueurChaine1
       '''pour''' j '''de''' 1 '''à''' longueurChaine2
           '''si''' chaine1[i] = chaine2[j] '''alors''' coût := 0
                                '''sinon''' coût := 1
           d[i, j] := minimum(
                                d[i-1, j  ] + 1,     ''// effacement''
                                d[i, j-1] + 1,     ''// insertion''
                                d[i-1, j-1] + coût   ''// substitution''
                            )   '''retourner''' d[longueurChaine1, longueurChaine2]L'invariant est qu'on peut transformer le segment initial chaine11..i en chaine21..j en utilisant un nombre minimal de dj opérations. L'algorithme achevé, la solution est contenue dans la dernière position à droite de la rangée du bas de la matrice.Améliorations possiblesL'algorithme présenté a une complexité temporelle et spatiale de (m+1)\times(n+1). En effet, il faut stocker et remplir la matrice en mémoire. Cependant, il est possible d'effectuer le calcul en ne gardant qu'une ligne et qu'une colonne en mémoire, ce qui réduit grandement la quantité de mémoire utilisée à O(m).D'autre part, il est aussi possible d'expliciter la suite d'opérations réellement effectuée par l'algorithme en utilisant une deuxième matrice où l'on stocke pour chaque opération, l'opération parente. Une fois le calcul effectué, on peut reconstruire la chaîne en suivant cette matrice depuis sa fin. Ce processus permet par exemple d'apparier les caractères de a avec ceux de b.ImplémentationsPlusieurs implémentations sont disponibles : Levenshtein distance.Exemple de déroulement de l'algorithmePour comprendre le fonctionnement de cet algorithme, prenons un exemple:Soit s= « NICHE » Soit t= « CHIENS »IntuitivementIntuitivement, on voit bien que l'on peut transformer la chaîne s en t en 5 étapes:Suppression de N et IAjout de I, N et S → CHIENSLa distance de Levenshtein d entre "NICHE" et "CHIENS" est donc d'au plus 5. On peut se convaincre par l'expérience que 5 est effectivement la distance entre les deux chaînes (l'algorithme de la distance de Levenshtein ne s'occupe pas de déplacement, il ne sait détecter que la suppression ou l'insertion d'une lettre, ainsi que le remplacement d'une lettre par une autre). Pour le vérifier formellement, on peut appliquer l'algorithme (ou tout essayer manuellement).FonctionnementSoit n la longueur de la chaîne s (ici n=5) Soit m la longueur de la chaîne t (ici m=6)Si n=0 alors retourner d=m et quitter Si m=0 alors retourner d=n et quitterConstruire une matrice M de n+1 lignes et m+1 colonnes. Initialiser la première ligne par la matrice ligne [ 0,1,….., m-1, m] et la première colonne par la matrice colonne [ 0,1,….., n-1, n]CHIENS0123456N1000000I2000000C3000000H4000000E5000000Soit Cout(i, j)=0 si A(i)=B(j) et Cout(i, j)=1 si A(i)!=B(j) On a donc ici la matrice Cout:CHIENSN111101I110111C011111H101111E111011On remplit ensuite la matrice M en utilisant la règle suivante&nbsp; Mj est égale au minimum de:L’élément directement avant plus 1: Mj + 1. (effacement)L’élément directement au dessus plus 1: Mj-1 + 1. (insertion)Le diagonal précédent plus le coût: Mj-1 + Cout(i, j). (substitution)Dans notre cas, le remplissage de la première ligne donne alors:CHIENS0123456N1123445I2000000C3000000H4000000E5000000Nous réitérons cette opération jusqu'à remplir la matrice :CHIENS0123456N11|supprimer 'N''''23445I22|supprimer 'I''''22345C32|'C' égal 'C''''33345H432|'H' égal 'H''''3|ajouter 'I''''445E54333|'E' égal 'E''''4|ajouter 'N''''5|ajouter 'S''''La distance de Levenshtein entre les mots s et t se retrouve en Mm.Ici, on retrouve bien les 5 opérations trouvées de manière intuitive, la dernière matrice fournit aussi explicitement les opérations nécessaires pour passer d'une chaîne de caractères à l'autre.GénéralisationEn remplaçant chaîne de caractères par séquence de symboles, les symboles étant comparables par un opérateur d'égalité, on peut définir une distance d'édition fonctionnant sur d'autres types que des chaînes de caractères.Voir aussiDistance de HammingDistance d'édition sur les arbresdiffImplémentation en plusieurs langages de programmationJaroDistance de Jaro-WinklerIndice et distance de JaccardTF-IDFSam ChapmanWilliam W. Cohen Catégorie:Algorithme sur les chaînes de caractères Catégorie:Théorie des codesaf:Levenshteinafstand de:Levenshtein-Distanz en:Levenshtein distance es:Distancia de Levenshtein fi:Levenšteinin etäisyys it:Distanza di Levenshtein ja:レーベンシュタイン距離 lv:Levenšteina attālums nl:Levenshteinafstand nn:Levenshtein-distanse pl:Odległość Levenshteina pt:Distância Levenshtein ru:Расстояние Левенштейна sr:Левенштајново растојање sv:Levenshteinavstånd tg:Масофаи Левенштейн uk:Відстань Левенштейна vi:Khoảng cách Levenshtein zh:編輯距離