Le système binaire est un système de numération utilisant la base 2. On nomme couramment bit (de l'anglais binary digit, soit « chiffre binaire ») les chiffres de la numération binaire. Ceux ci ne peuvent prendre que deux valeurs, notées par convention 0 et 1.C'est un concept essentiel de l'informatique. En effet, les processeurs des ordinateurs sont composés de millions de transistors (imprimés sur un circuit électronique) qui chacun ne gère que des bits 0 (« le courant ne passe pas ») et 1 (« le courant passe »).Un calcul informatique n'est donc qu'une suite d'opérations sur des paquets de 0 et de 1, appelés octets lorsqu'ils sont regroupés par 8.ConversionsLe codage le plus courant est l'équivalent en base deux de la numération de position que nous utilisons quotidiennement en base 10.Énumération des premiers nombresLes premiers nombres s'écrivent :décimal  binaire
   0       0000
   1       0001
   2       0010
   3       0011
   4       0100
   5       0101(Sachant que les colonnes binaires correspondent respectivement à 8,4,2 et 1)On passe d'un nombre binaire au suivant en ajoutant 1, comme en décimal, sans oublier les retenues et en utilisant les tables d'additions suivantes: 0+0=0    0+1=1    1+0=1   1+1=10ainsi:   11
+   1
 ====
  100Détail :1 + 1 = 10           =&gt; on pose 0, et retient 1
1 + 1(retenue) = 10  =&gt; on pose 0, et retient 1
0 + 1(retenue) = 1   =&gt;         1-L'arithmétique binaire (plus simplement le calcul binaire) est utilisé par les systèmes électroniques les plus courants (calculatrices, ordinateurs, etc.) car le niveau de tension peut servir à représenter les deux chiffres 0 et 1 ; 0 représentant l'état bas et 1 l'état haut.Tout nombre peut s'écrire en binaire, c'est à dire qu'il se décompose en somme de puissances de 2(1;2;4;8;16;32;64;...), par exemple 35 se décompose en :(1*2^)+(0*2^)+(0*2^)+(0*2^)+(1*2^)+(1*2^) = 32 + 2 + 1 = 35donc le nombre décimal 35 se note 100011 en binaire.Expression d'un nombreUn nombre décimal à plusieurs chiffres tel que 123 s'exprime ainsi :1*100+2*10+3*1=1*10^+2*10^+3*10^Sa représentation en binaire est 1111011 et s'exprime de la même façon :1*64+1*32+1*16+1*8+0*4+1*2+1*1=1*2^+1*2^+1*2^+1*2^+0*2^+1*2^+1*2^suite de 1010-10100Représentation des entiers positifsPour trouver la représentation binaire d'un nombre, on le décompose en somme de puissances de 2. Par exemple avec le nombre dont la représentation décimale est 59 :  59 = '''1'''×32 + '''1'''×16 + '''1'''×8 + '''0'''×4 + '''1'''×2 + '''1'''×1
  59 = '''1'''×2&lt;small&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/small&gt; + '''1'''×2&lt;small&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/small&gt; + '''1'''×2&lt;small&gt;³&lt;/small&gt; + '''0'''×2&lt;small&gt;²&lt;/small&gt; + '''1'''×2&lt;small&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/small&gt; + '''1'''×2&lt;small&gt;&lt;sup&gt;0&lt;/sup&gt;&lt;/small&gt;
  59 = '''111011''' en binaireAvec N bits, ce système permet de représenter les nombres entre 0 et 2N-1. Il est donc possible de compter sur ses dix doigts jusqu'à 1023 (210-1) en binaire. Il suffit d'affecter à chaque doigt une valeur binaire (pouvant être représenté par un doigt plié).Doigt                  Main            Puis. Valeur en
                                       de 2  numération
                                             décimale
Auriculaire   de la main droite levé   2^0        1
Annulaire                »             2^1   +    2
Majeur                   »             2^2   +    4
Index                    »             2^3   +    8
Pouce                    »             2^4   +   16
Pouce         de la main gauche levé   2^5   +   32
Index                    »             2^6   +   64
Majeur                   »             2^7   +  128
Annulaire                »             2^8   +  256
Auriculaire              »             2^9   +  512
                                            -------
                                      Somme  =1 023(Pour mémoire                          2^10  =1 024)Ceci confirme la formule2^10-1=1 024-1
      =1 023On remarque qu'avec 10 doigts on peut prendre en compte les 10 premières puissances de 2 s'échelonnant de 2^0 à 2^9 c'est-à-dire la somme des 10 premières puissances de 2.Représentation des entiers négatifsPour compléter la représentation des entiers, il faut pouvoir écrire des entiers négatifs. On ajoute pour cela à la représentation un bit de signe, placé en tête. Un bit de signe nul indique une valeur positive, un bit de signe positionné à un une valeur négative. Cette règle permet de rester cohérent avec le système de représentation des entiers positifs : il suffit d'ajouter un 0 en tête de chaque valeur.Complément à unCe codage, fort simple, consiste à inverser la valeur de chaque bit composant une valeur binaire.Par exemple, pour obtenir -5 :0101 valeur décimale 5
1010 complément à unLe souci avec un tel système est qu'il y a toujours deux représentations de la valeur 0 pour un nombre de bit donné.Complément à deuxAfin de pallier ce défaut, on a introduit la représentation par complément à deux. Celle-ci consiste à réaliser un complément à un de la valeur, puis d'ajouter 1 au résultat.Par exemple pour obtenir -5:0101 codage de 5 en binaire
1010 complément à un
1011 on ajoute 1 : représentation de -5 en complément à deuxCe codage a l'avantage de ne pas nécessiter de différenciation spéciale des nombres positifs et négatifs, et évite en particulier le problème d'ordinateurs anciens (Control Data 6600) qui avaient un « +0 » et un « -0 » dont il fallait faire comprendre aux circuits de tests que c'était le même nombre ! Voici une addition de -5 et +7 réalisée en complément à deux sur 4 bits :-5        1011 
+7        0111
__        ____
 2    (1) 0010     (on 'ignore' la retenue)   Avec n bits, ce système permet de représenter les nombres entre -2n-1 et 2n-1-1.Du système décimal vers le système binairePour développer l'exemple ci-dessus, le nombre  écrit en base décimale provient de la somme de nombres ci-après écrits en base décimale. À dire vrai, pour proposer une méthode plus simple à comprendre, il faut trouver la puissance de 2 la plus grande possible inférieure ou égale au nombre de départ. On soustrait au nombre d'origine (RO) cette puissance, en notant un 1, puis l'on cherche à nouveau un multiple (RM) pour le reste (Rr).1. RO = RM1+Rr12. Rr1 = RM2+Rr23. Rr2 = RM3+Rr3... 32 768  1 fois  32 768  on fait 2 multiplié 14 fois par lui même soit 2&lt;sup&gt;&lt;small&gt;15&lt;/small&gt;&lt;/sup&gt;
+     0  0 fois  16 384  on fait 2 multiplié 13 fois par lui même soit 2&lt;sup&gt;&lt;small&gt;14&lt;/small&gt;&lt;/sup&gt;
+ 8 192  1 fois   8 192         idem         12      idem              2&lt;sup&gt;&lt;small&gt;13&lt;/small&gt;&lt;/sup&gt;
+ 4 096  1 fois   4 096         idem         11      idem              2&lt;sup&gt;&lt;small&gt;12&lt;/small&gt;&lt;/sup&gt;
+     0  0 fois   2 048         idem         10      idem              2&lt;sup&gt;&lt;small&gt;11&lt;/small&gt;&lt;/sup&gt;
+     0  0 fois   1 024         idem          9      idem              2&lt;sup&gt;&lt;small&gt;10&lt;/small&gt;&lt;/sup&gt;
+   512  1 fois     512         idem          8      idem              2&lt;sup&gt;&lt;small&gt;9&lt;/small&gt;&lt;/sup&gt;
+   256  1 fois     256         idem          7      idem              2&lt;sup&gt;&lt;small&gt;8&lt;/small&gt;&lt;/sup&gt;
+     0  0 fois     128         idem          6      idem              2&lt;sup&gt;&lt;small&gt;7&lt;/small&gt;&lt;/sup&gt;
+     0  0 fois      64         idem          5      idem              2&lt;sup&gt;&lt;small&gt;6&lt;/small&gt;&lt;/sup&gt;
+     0  0 fois      32         idem          4      idem              2&lt;sup&gt;&lt;small&gt;5&lt;/small&gt;&lt;/sup&gt;
+    16  1 fois      16         idem          3      idem              2&lt;sup&gt;&lt;small&gt;4&lt;/small&gt;&lt;/sup&gt;
+     8  1 fois       8         idem          2      idem              2&lt;sup&gt;&lt;small&gt;3&lt;/small&gt;&lt;/sup&gt;
+     4  1 fois       4         idem          1      idem              2&lt;sup&gt;&lt;small&gt;2&lt;/small&gt;&lt;/sup&gt;
+     0  0 fois       2         idem          0      idem              2&lt;sup&gt;&lt;small&gt;1&lt;/small&gt;&lt;/sup&gt; = 2
+     1  1 fois       1                                                 2&lt;sup&gt;&lt;small&gt;0&lt;/small&gt;&lt;/sup&gt; = 1
=45 853Soit écrit en système positionnel et en numération décimale (en écrivant les puissances de 2) :45 853 = 1×2&lt;sup&gt;15&lt;/sup&gt; + 0×2&lt;sup&gt;14&lt;/sup&gt; + 1×2&lt;sup&gt;13&lt;/sup&gt; + 1×2&lt;sup&gt;12&lt;/sup&gt; + 0×2&lt;sup&gt;11&lt;/sup&gt; + 0×2&lt;sup&gt;10&lt;/sup&gt; + 1×2&lt;sup&gt;9&lt;/sup&gt;  + 1×2&lt;sup&gt;8&lt;/sup&gt;  + 
         0×2&lt;sup&gt;7&lt;/sup&gt;  + 0×2&lt;sup&gt;6&lt;/sup&gt;  + 0×2&lt;sup&gt;5&lt;/sup&gt;  + 1×2&lt;sup&gt;4&lt;/sup&gt;  + 1×2&lt;sup&gt;3&lt;/sup&gt;  + 1×2&lt;sup&gt;2&lt;/sup&gt;  + 0×2&lt;sup&gt;1&lt;/sup&gt;  + 1×2&lt;sup&gt;0&lt;/sup&gt;Soit en système positionnel et en numération binaire puisque l'on ne reporte pas les puissances de 245 853 décimal s'écrit 1011 0011 0001 1101 binaire (séparés par groupes de 4 bits pour aérer la lecture).Ce nombre nécessite 16 bits pour son écriture (il est compris entre 215 et 216). L'autre méthode pour convertir un nombre décimal en base 2 est d'utiliser des successions de divisions par le nombre 2. Ainsi, on a:45853 / 2 = 22926 reste 1
22926 / 2 = 11463 reste 0
11463 / 2 =  5731 reste 1
 5731 / 2 =  2865 reste 1
 2865 / 2 =  1432 reste 1
 1432 / 2 =   716 reste 0
  716 / 2 =   358 reste 0
  358 / 2 =   179 reste 0
  179 / 2 =    89 reste 1
   89 / 2 =    44 reste 1
   44 / 2 =    22 reste 0
   22 / 2 =    11 reste 0
   11 / 2 =     5 reste 1
    5 / 2 =     2 reste 1
    2 / 2 =     1 reste 0
    1 / 2 =     0 reste 1Soit (en lisant les restes obtenus en sens inverse): 1011001100011101Entre les bases 2, 8 et 16Du binaire vers octal ou hexadécimalLes bases 8 (octale) et 16 (hexadécimale) sont des bases multiples de la base 2. Ces deux bases ont été couramment employées en informatique et pour des raisons pratiques; ces bases étant fortement liées à la base 2 et les nombres écrits dans ces bases étant plus "manipulables" (car d'écriture plus courte) par l'intellect humain. L'écriture de nombres dans ces bases est facilement obtenue par regroupement de chiffres de l'écriture du nombre en base 2.Octal : base 8 : 8 = 2^3, il suffit de regrouper à partir de la droite et par paquets de 3 les chiffres binaires (voir bāguà). Chaque paquet de 3 (le dernier devant être parfois complété par des 0 à gauche), étant l'écriture binaire d'un chiffre en base 8 (08=000, 18=001, 28=010, 38=011, 48=100, 58=101, 68=110, 78=111).101011011102 va s'écrire 10 101 101 110 et en convertissant la valeur de chacun des blocs en un chiffre octal, on obtient le nombre octal 25568.Hexadécimal : base 16 : 16 = 2^4, donc on regroupe à partir de la droite et par paquets de 4 les chiffres binaires. Chaque paquet de 4 bits étant la représentation binaire d'un chiffre en base 16. Il faut donc 16 chiffres, il a été décidé d'utiliser les 10 chiffres décimaux plus les 6 premiers caractères de l'alphabet avec la convention suivante: A16=1010=10102, B16=1110=10112, C16=1210=11002, D16=1310=11012, E16=1410=11102 et F16=1510=11112.101011011102 va s'écrire 101 0110 1110 et en convertissant la valeur de chacun des blocs en décimal on obtient : 5, 6, 14 c'est-à-dire 56E16.On pourrait facilement étendre ce principe à toutes les bases qui sont puissances de 2.Vers le binaireIl suffit de convertir la valeur de chacun des chiffres sous leur forme binaire.1A2F16 va s'écrire 1, 10=8+2, 2, 15=8+4+2+1 soit 1&nbsp;1010&nbsp;0010&nbsp;111121568 va s'écrire 1, 5=4+1, 6=4+2 soit 1&nbsp;101&nbsp;1102Table des valeurs des groupements de chiffres binairesBinaireDécimalOctalHexadécimal00000000001111001022200113330100444010155501106660111777|BinaireDécimalOctalHexadécimal100081081001911910101012A10111113B11001214C11011315D11101416E11111517F|La soustractionLa soustraction en binaire se déroule de la même manière qu’en décimal.Principe de base :0 − 0 = 00 − 1 = 1 (avec retenue)1 − 0 = 11 − 1 = 0Exemple de soustraction :    *   * * *   (les colonnes avec * contiennent des retenues)
  1 1 0 1 1 1 0
−     1 0 1 1 1
----------------
= 1 0 1 0 1 1 1Code de Gray ou binaire réfléchiCe codage permet de ne faire changer qu'un seul bit à la fois quand un nombre est augmenté d'une unité. Le nom du code vient de l'ingénieur américain Frank Gray qui déposa un brevet sur ce code en 1953. Monsieur Louis Gros publia en 1872 un opuscule où ce code était présenté pour la première fois en lien avec un casse-tête. Monsieur Gros était clerc de notaire à Lyon.codage binaire classiqueCodage Gray ou binaire réfléchi00000000001000110001200102001130011300104010040110501015011160110601017011170100Pour passer d'une ligne à la suivante, on inverse le bit le plus à droite possible conduisant à un nombre nouveau.Le nom de code binaire réfléchi vient d'une méthode de construction plus pratique pour choisir quel bit inverser quand on passe d'un nombre au suivant:On choisit un code de départ: zéro est codé 0 et un est codé 1.Puis, à chaque fois qu'on a besoin d'un bit supplémentaire, on symétrise les nombres déjà obtenus (comme une réflexion dans un miroir).Enfin, on rajoute un 0 au début des "anciens" nombres, et un 1 au début des nouveaux nombres.Exemple :0 0          0  .0    0  00     0  .00     0  000
1 1          1  .1    1  01     1  .01     1  001
     miroir-&gt;------             2  .11     2  011
             2  .1    2  11     3  .10     3  010
             3  .0    3  10     ------- 
                                4  .10     4  110
                                5  .11     5  111
                                6  .01     6  101
                                7  .00     7  100Une autre méthode de calcul permettant de passer d'un nombre de Gray au suivant, et qui présente l'avantage de ne pas nécessiter de connaître l'ensemble des nombres précédents est la suivante :si le nombre de 1 est pair, alors le dernier chiffre doit être inversésinon, il faut repérer le 1 situé le plus à droite et inverser le chiffre situé immédiatement à gauche de celui-ci.Ce code est surtout utilisé pour des capteurs de positions, par exemple sur des règles optiques. En effet, si on utilise le code binaire standard, lors du passage de la position un (01) à deux (10), permutation simultanée de 2 bits, il y a un risque de passage transitoire par trois (11) ou zéro (00), ce qu'évite le code de Gray.On remarquera que le passage du maximum (sept sur 3 bits) à zéro se fait également en ne modifiant qu'un seul bit. Ceci permet par exemple d'encoder un angle, comme la direction d'une girouette : 0=''Nord'', 1=''Nord-Est'', 2=''Est'', ... 7=''Nord-Ouest''. Le passage de Nord-Ouest à Nord se fait également sans problème en ne changeant qu'un seul bit (voir Roue de codage).Le décodage des signaux lumineux d'un axe de souris mécanique est un décodage de code de Gray à 2 bits (décodage différentiel dans ce cas, car ce que l'on veut obtenir n'est pas la valeur décodée mais les transitions ±1 mod 4 de la valeur décodée).Le code Gray sert également dans les tables de Karnaugh utilisées lors de la conception de circuits logiques.Algorithme de codage d'un nombre n en code gray g : g = n ^(n &gt;&gt; 1)Algorithme de décodage rapide pour des mots de 64 bits (pour des mots de 32 bits, remplacer 32 par 16) : long grayInverse(long n) 
   Décimal codé binaire (« binary coded decimal », ou ''BCD'')Ce codage consiste à représenter chacun des chiffres de la numérotation décimale sur 4 bits:1994 =  0001    1001   1001   0100
      1×1000 + 9×100 + 9×10 + 4×1Il présente l'avantage de simplifier la conversion avec la notation décimale.Avec n bits (n multiple de 4), il est possible de représenter les nombres entre 0 et 10n/4-1. Soit approximativement entre 0 et 1.778n-1. Le BCD est un code redondant, en effet certaines combinaisons ne sont pas utilisées (comme 1111 par exemple).Cette représentation évite par construction tous les problèmes gênants de cumul d'arrondi qui interviendraient lors de la manipulation de grands nombres dépassant la taille des circuits en arithmétique entière et obligent à recourir au flottant. Il est cependant possible de manipuler des nombres à précision arbitraire en utilisant un codage plus efficace que le BCD.Il existe des variantes du codage BCD :code Aiken où 0, 1, 2, 3, 4 sont codés comme en BCD et 5, 6, 7, 8, 9 sont codés de 1011 à 1111. Il permet d'obtenir le complément à 9 en permutant les 1 et les 0.codage binaire excédant 3 qui consiste à représenter le chiffre à coder + 3.ApplicationsThéorie de l'informationEn théorie de l'information, l'entropie d'une source d'information est exprimée en bits. La théorie elle-même est indifférente à la représentation des grandeurs qu'elle utilise.LogiqueLa logique classique est une logique bivalente: une proposition est soit vraie, soit fausse. Il est donc possible de représenter la vérité d'une proposition par un chiffre binaire. On peut par exemple modéliser les opérations de l'arithmétique binaire à l'aide de l'algèbre de Boole.L'algèbre de Boole représente un cas très particulier d'usage des probabilités ne faisant intervenir que les seules valeurs de vérité 0 et 1. Voir Théorème de Cox-Jaynes.InformatiqueLe binaire est utilisé en informatique car il permet de modéliser le fonctionnement des composants de commutation comme le TTL ou le CMOS. La présence d'un seuil de tension au bornes des transistors, en négligeant la valeur exacte de cette tension, représentera 0 ou 1. Par exemple le chiffre 0 sera utilisé pour signifier une absence de tension à 0,5V près, et le chiffre 1 pour signifier sa présence à plus de 0,5V. cette marge de tolérance permet de pousser les cadences des microprocesseurs à des valeurs atteignant sans problème (hormis d'échauffement) plusieurs gigahertz. Ne sachant pas techniquement réaliser des composants électroniques à plus de deux états stables (0 ou plus de 0,5V), on n'utilise que la logique (bivalente) et donc le système binaire.En informatique, la représentation binaire permet de clairement manipuler des bits : chaque chiffre binaire correspond à un bit. La représentation binaire nécessitant l'usage de beaucoup de chiffres (même pour des nombres assez petits), ce qui entraînerait d'importants problèmes de lisibilité et donc de risques d'erreur de transcription pour les programmeurs on lui préfère pour eux une représentation parfois octale ou plus fréquemment hexadécimale. La quasi totalité des microprocesseurs actuels travaillant avec des mots de 8, 16, 32 ou 64 bits, la notation hexadécimale permet de manipuler l'information par paquets de 4 bits (contre 3 pour la notation octale plus populaire du temps des premiers mini-ordinateurs DEC à 12 ou 36 bits).63 (10) = 111111 (2) = 77 (8) = 3F (16)64 (10) = 1000000 (2) = 100 (8) = 40 (16)255 (10) = 11111111 (2) = 377 (8) = FF (16)256 (10) = 100000000 (2) = 400 (8) = 100 (16)Voir aussiFormat des donnéesPréfixe binaireVirgule flottanteSystème bibi-binaire de Boby LapointeAlgèbre de BooleNombre négatifComplément à 1Complément à 2Auguste De MorganEntier en précision multipleLiens externesLe traitement numériqueMise en œuvre de la numérationTraducteur,Texte-Binaire-Hexadécimal-Décimal-Base64, etc...Convertisseur binaire - hexadecimal - décimalBinaire Catégorie:Calcul informatique Catégorie:Calcul numériqueaf:Binêre getallestelsel ar:نظام عد ثنائي bg:Двоична бройна система bs:Binarni sistem ca:Codi binari cs:Dvojková soustava cv:Иккĕллĕ шутлав йĕрки da:Binære talsystem de:Dualsystem el:Δυαδικό σύστημα en:Binary numeral system eo:Duuma sistemo es:Sistema binario et:Kahendsüsteem eu:Zenbaki-sistema bitar fa:دستگاه اعداد دودویی fi:Binäärijärjestelmä fur:Sisteme binari gl:Código binario he:בסיס בינארי hr:Binarni brojevni sustav ht:Sistèm binè hu:Kettes számrendszer ia:Systema binari id:Sistem bilangan biner is:Tvíundakerfi it:Sistema numerico binario ja:二進法 ka:ორობითი რიცხვები ko:이진법 la:Systema numericum binarium lmo:Còdas binari lt:Dvejetainė skaičiavimo sistema lv:Binārā skaitīšanas sistēma ml:ദ്വയാങ്കസംഖ്യാവ്യവസ്ഥ mr:द्विमान पद्धत ms:Sistem angka perduaan nl:Binair nn:Totalssystemet no:Binært tallsystem pl:Dwójkowy system liczbowy pt:Sistema binário (matemática) ro:Sistem binar ru:Двоичная система счисления sd:انگن جو ڏونائي سرشتو simple:Binary numeral system sk:Dvojková číselná sústava sl:Dvojiški številski sistem sq:Sistemi binar sr:Бинарни систем su:Sistim panomeran binér sv:Binära talsystemet th:เลขฐานสอง tr:İkili sayılar uk:Двійкова система числення ur:ثنائی عددی نظام vi:Hệ nhị phân vls:Binair reeknn yi:ביינערי zh:二进制