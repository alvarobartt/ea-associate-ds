En matemáticas, ciencias de la computación, y disciplinas relacionadas, un algoritmo (del latín, dixit algorithmus y éste a su vez del matemático persa al-Jwarizmi) es una lista bien definida, ordenada y finita de operaciones que permite hallar la solución a un problema. Dado un estado inicial y una entrada, a través de pasos sucesivos y bien definidos se llega a un estado final, obteniendo una solución. Los algoritmos son objeto de estudio de la algoritmia.En la vida cotidiana se emplean algoritmos en multitud de ocasiones para resolver diversos problemas. Algunos ejemplos se encuentran en los instructivos (manuales de usuario), los cuales muestran algoritmos para usar el aparato en cuestión o inclusive en las instrucciones que recibe un trabajador por parte de su patrón. También existen ejemplos de índole matemático, como el algoritmo de la división para calcular el cociente de dos números, el algoritmo de Euclides para calcular el máximo común divisor de dos enteros positivos, o el método de Gauss para resolver un Sistema lineal de ecuaciones.IntroducciónLa importancia de un algoritmo radica en mostrar la manera de llevar a cabo procesos y resolver mecánicamente problemas matemáticos o de otro tipo. Al igual que las funciones matemáticas, los algoritmos reciben una entrada y la transforman en una salida, comportándose como una caja negra. Sin embargo, no toda caja negra que convierta una entrada en una salida se puede considerar un algoritmo: para que un algoritmo pueda ser considerado como tal, debe ser una secuencia ordenada, finita y definida (formalización de su comportamiento) de instrucciones. De este modo se puede seguir y predecir el comportamiento del algoritmo para cualquier entrada posible (salvo algoritmos probabilistas, que tiene usualmente una salida distinta), a partir del seguimiento de esa secuencia de instrucciones, que como es ordenada y definida, no da lugar a ambigüedades y puede seguirse su traza.El concepto de algoritmo, aunque similar y obviamente relacionado, no debe confundirse con el concepto de programa. Mientras el primero es la especificación de un conjunto de pasos (operaciones, instrucciones, órdenes,...) orientados a la resolución de un problema (método), el segundo es ese conjunto de operaciones especificadas en un determinado lenguaje de programación y para un computador concreto, susceptible de ser ejecutado (o compilado o interpretado). Un algoritmo, estrictamente hablando, no puede ejecutarse hasta que se implementa, ya sea en un lenguaje de programación, en un circuito eléctrico, en un aparato mecánico, usando papel y lápiz, o en algún otro modelo de computación.La mayoría de los algoritmos involucran métodos de organizar los datos que intervienen en el cómputo. Estos objetos creados son llamados, de esta manera la estructura de los datos, y también son objetos centrales del estudio en la informática. De esta forma, los algoritmos y estructuras de los datos van siempre de la mano. Los algoritmos simples pueden dar lugar a una estructura de datos complicada y, recíprocamente, los algoritmos complicados pueden usar estructuras de los datos simples.Cuando usamos una computadora para ayudarnos a resolver un problema, nos enfrentamos típicamente con varios posibles esquemas. Para los problemas pequeños, lo que apenas importa es que lo usemos, con tal de que se tenga uno que resuelva el problema correctamente. Para los problemas grandes (o aplicaciones dónde nosotros necesitamos resolver un gran número de problemas pequeños), sin embargo, nos motivamos en inventar métodos que usan tiempo eficazmente de forma rápida como sea posible.Cuando un programa de computadora es grande o complejo, este será desarrollado con mucho esfuerzo, ya que se debe comprender y definir el problema a ser resuelto, manejando su complejidad, y descomponiéndolo en partes más pequeñas que puedan resolverse más fácilmente. A menudo, muchos de los algoritmos que se necesitan, después de la descomposición son triviales al instrumento.Características de los algoritmosEl científico de computación Donald Knuth ofreció una lista de cinco propiedades, que son ampliamente aceptadas como requisitos para un algoritmo:Carácter finito. "Un algoritmo siempre debe terminar después de un número finito de pasos".Precisión. "Cada paso de un algoritmo debe estar precisamente definido; las operaciones a llevar a cabo deben ser especificadas de manera rigurosa y no ambigua para cada caso".Entrada. "Un algoritmo tiene cero o más entradas: cantidades que le son dadas antes de que el algoritmo comience, o dinámicamente mientras el algoritmo corre. Estas entradas son tomadas de conjuntos específicos de objetos".Salida. "Un algoritmo tiene una o más salidas: cantidades que tienen una relación específica con las entradas".Eficacia. "También se espera que un algoritmo sea eficaz, en el sentido de que todas las operaciones a realizar en un algoritmo deben ser suficientemente básicas como para que en principio puedan ser hechas de manera exacta y en un tiempo finito por un hombre usando lápiz y papel".Knuth admite que, aunque su descripción pueda ser intuitivamente clara, carece de rigor formal, puesto que no está exactamente claro qué significa "precisamente definido", "de manera rigurosa y no ambigua", o "suficientemente básicas", y así sucesivamente..A partir del carácter finito y de la salida se deduce que ante una misma situación inicial (o valores de entrada) un algoritmo debe proporcionar siempre el mismo resultado (o salida), con excepción de los algoritmos probabilistas.Algoritmos y funciones Formalmente, un algoritmo calcula a una función. Como cualquier conjunto finito es numerable, y cualquier conjunto numerable se puede expresar en términos del conjunto de los números naturales (infinito, pero numerable, de hecho no existe otro conjunto más grande que sea también numerable), en esencia, todo algoritmo calcula a funciones definidas en los números naturales. En este punto, una función está parcial o totalmente definida. Una función es parcial cuando hay números naturales que no pertenecen a su dominio (es decir, hay números naturales sobre los que no está definida la función), y una función es total en caso contrario.Si una función es parcial, el algoritmo que lo calcula solo devolverá un resultado (es decir gasta un tiempo de cálculo finito) para los valores en los que la función está definida, no devolviendo resultado (el tiempo de cálculo es infinito) para el resto de valores. Si un algoritmo que calcula a una función parcial devolviera un resultado para los valores no definidos de la función, entonces no calcularía a esa función sino a otra. Del mismo modo, un algoritmo que calcula a una función total siempre devuelve un resultado para todo valor, y que al igual que las funciones parciales, éste debe coincidir exactamente con el valor que devuelve la función a la que calcula; y reiterativamente, en caso contrario, no calcularía a esa función sino a otra. Así, todo algoritmo calcula a una función definida sobre los números naturales, sea cuál sea ésta su naturaleza.Toda función para la cual exista un algoritmo que lo calcule se denomina función computable (parcialmente computable o totalmente computable depende del grado de definición de la función en cuestión), pero existen funciones que no pueden ser calculadas como la función de Ackermann, a este último tipo de funciones se las denomina funciones no computables.Medios de expresión de un algoritmoLos algoritmos pueden ser expresados de muchas maneras, incluyendo al lenguaje natural, pseudocódigo, diagramas de flujo y lenguajes de programación entre otros. Las descripciones en lenguaje natural tienden a ser ambiguas y extensas. El usar pseudocódigo y diagramas de flujo evita muchas ambigüedades del lenguaje natural. Dichas expresiones son formas más estructuradas para representar algoritmos; no obstante, se mantienen independientes de un lenguaje de programación específico.La descripción de un algoritmo usualmente se hace en tres niveles:Descripción de alto nivel. Se establece el problema, se selecciona un modelo matemático y se explica el algoritmo de manera verbal, posiblemente con ilustraciones y omitiendo detalles.Descripción formal. Se usa pseudocódigo para describir la secuencia de pasos que encuentran la solución.Implementación. Se muestra el algoritmo expresado en un lenguaje de programación específico o algún objeto capaz de llevar a cabo instrucciones.También es posible incluir un teorema que demuestre que el algoritmo es correcto, un análisis de complejidad o ambos.Diagrama de flujothumb|[[Diagrama de flujo que expresa un algoritmo para calcular la raíz cuadrada de un número x]]  Los diagramas de flujo son descripciones gráficas de algoritmos; usan símbolos conectados con flechas para indicar la secuencia de instrucciones y están regidos por ISO.Los diagramas de flujo son usados para representar algoritmos pequeños, ya que abarcan mucho espacio y su construcción es laboriosa. Por su facilidad de lectura son usados como introducción a los algoritmos, descripción de un lenguaje y descripción de procesos a personas ajenas a la computación.Pseudocódigo Pseudocódigo es la descripción de un algoritmo que asemeja a un lenguaje de programación pero con algunas convenciones del lenguaje natural. Tiene varias ventajas con respecto a los diagramas de flujo, entre las que se destaca el poco espacio que se requiere para representar instrucciones complejas. El pseudocódigo no está regido por ningún estándar. pseudo viene de falso y por ende es un codigo al que aunque es entendible no se aplica al proceso que debe realizar la maquina.Máquina de Turing La máquina de Turing es un modelo matemático, diseñado por Alan Turing, que formaliza el concepto de algoritmo. A este modelo se le refiere comúnmente como la "descripción de más bajo nivel" por el hecho de que no utiliza ninguna expresión coloquial.ImplementaciónMuchos algoritmos son ideados para implementarse en un programa. Sin embargo, los algoritmos pueden ser implementados en otros medios, como una red neuronal, un circuito eléctrico o un aparato mecánico. Algunos algoritmos inclusive se diseñan especialmente para implementarse usando lápiz y papel. El algoritmo de multiplicación tradicional, el algoritmo de Euclides, la criba de Eratóstenes y muchas formas de resolver la raíz cuadrada son sólo algunos ejemplos.Análisis de algoritmos Como medida de la eficiencia de un algoritmo, se suelen estudiar los recursos (memoria y tiempo) que consume el algoritmo. El análisis de algoritmos se ha desarrollado para obtener valores que de alguna forma indiquen (o especifiquen) la evolución del gasto de tiempo y memoria en función del tamaño de los valores de entrada.El análisis y estudio de los algoritmos es una disciplina de las ciencias de la computación y, en la mayoría de los casos, su estudio es completamente abstracto sin usar ningún tipo de lenguaje de programación ni cualquier otra implementación; por eso, en ese sentido, comparte las características de las disciplinas matemáticas. Así, el análisis de los algoritmos se centra en los principios básicos del algoritmo, no en los de la implementación particular. Una forma de plasmar (o algunas veces "codificar") un algoritmo es escribirlo en pseudocódigo o utilizar un lenguaje muy simple tal como Léxico, cuyos códigos pueden estar en el idioma del programador.Algunos escritores restringen la definición de algoritmo a procedimientos que deben acabar en algún momento, mientras que otros consideran procedimientos que podrían ejecutarse eternamente sin pararse, suponiendo el caso en el que existiera algún dispositivo físico que fuera capaz de funcionar eternamente. En este último caso, la finalización con éxito del algoritmo no se podría definir como la terminación de éste con una salida satisfactoria, sino que el éxito estaría definido en función de las secuencias de salidas dadas durante un periodo de vida de la ejecución del algoritmo. Por ejemplo, un algoritmo que verifica que hay más ceros que unos en una secuencia binaria infinita debe ejecutarse siempre para que pueda devolver un valor útil. Si se implementa correctamente, el valor devuelto por el algoritmo será válido, hasta que evalúe el siguiente dígito binario. De esta forma, mientras evalúa la siguiente secuencia podrán leerse dos tipos de señales: una señal positiva (en el caso de que el número de ceros sea mayor que el de unos) y una negativa en caso contrario. Finalmente, la salida de este algoritmo se define como la devolución de valores exclusivamente positivos si hay más ceros que unos en la secuencia y, en cualquier otro caso, devolverá una mezcla de señales positivas y negativas.Ejemplo de algoritmoEl problema consiste en encontrar el máximo de un conjunto de números. Para un ejemplo más complejo véase Algoritmo de Euclides.Descripción de alto nivelDado un conjunto finito C de números, se tiene el problema de encontrar el número más grande. Sin pérdida de generalidad se puede asumir que dicho conjunto no es vacío y que sus elementos están numerados como c_0,c_1,\dots,c_n.Es decir, dado un conjunto C=\ se pide encontrar m tal que x\leq m para todo elemento x que pertenece al conjunto C.Para encontrar el elemento máximo, se asume que el primer elemento (c_0) es el máximo; luego, se recorre el conjunto y se compara cada valor con el valor del máximo número encontrado hasta ese momento. En el caso que un elemento sea mayor que el máximo, se asigna su valor al máximo. Cuando se termina de recorrer la lista, el máximo número que se ha encontrado es el máximo de todo el conjunto.Descripción formalEl algoritmo escrito de una manera más formal, esto es, en pseudocódigo tendría el siguiente aspecto: Sobre la notación:"\gets" representa la asignación entre dos objetos. Por ejemplo, m\leftarrow x significa que el objeto m cambia su valor por el de x"devolver" termina el algoritmo y devuelve el valor a su derecha (en este caso, el máximo de C)ImplementaciónEn lenguaje C:  int max(int c[], int n)
  return m;  En lenguaje Java: public int max( int c[] ) 
   
   return m;
 En lenguaje Visual Basic 8 (2005): Public Function max(C As Integer()) As Integer
    Dim n As Integer = C.GetLength(0)
    Dim m As Integer = C(0)
    For i As Integer = 1 To n
        If C(i) &gt; m Then
            m = C(i)
        End If
    Next
    Return m
End FunctionEn lenguaje Delphi:  function Max(const ListaNumeros: array of Integer): Integer; var vTemp, i: Integer;beginvTemp:= 0;for i:= 1 to High(ListaNumeros) do
 if ListaNumeros[i] &gt; vTemp then
  vTemp:= ListaNumeros[i];Result:= vTemp;end;  En lenguaje Ada type T_Conjunto is array &lt;&gt; of Integer;
function Maximo
  (Conjunto : T_Conjunto) return Integer 
is
   Temporal : Integer := Conjunto (1);
begin
   for I in 2 .. Conjunto'Last loop
      if Conjunto (I) &gt; Temporal then
         Temporal := Conjunto (I);
      end if;
   end loop;
   return Temporal;
end Maximo; En lenguaje Python  def max©: n=len(c)
 m=c[0]
 for i in range(0,n):
   if c[i]&gt;m: m=c[i]
 return mAnálisisEl algoritmo anterior tiene un orden de eficiencia en tiempo de  O(n), en la notación O mayúscula, siendo n el tamaño de la entrada, más concretamente, en este caso, el número de elementos de C. Además, como el algoritmo necesita recordar un único valor (el máximo) requiere un espacio adicional de O(1) (hay que tener en cuenta que el tamaño de las entradas no se considera como memoria usada por el algoritmo).HistoriaLa palabra algoritmo proviene del nombre del matemático llamado Muhammad ibn Musa al-Khwarizmi que vivió entre los siglos VIII y IX. Su trabajo consistió en preservar y difundir el conocimiento de la antigua Grecia y de la India. Sus libros eran de fácil comprensión, de ahí que su principal logro no fuera el de crear nuevos teoremas o corrientes de pensamiento, sino el de simplificar la matemática a punto tal que pudieran ser comprendidas y aplicadas por un mayor número de personas. Cabe destacar cómo señaló las virtudes del sistema decimal indio (en contra de los sistemas tradicionales árabes) y cómo explicó que, mediante una especificación clara y concisa de cómo calcular sistemáticamente, se podrían definir algoritmos que fueran usados en dispositivos mecánicos en vez de las manos (por ejemplo, ábacos). También estudió la manera de reducir las operaciones que formaban el cálculo. Es por esto que aún no siendo el creador del primer algoritmo, el concepto lleva aunque no su nombre, sí su pseudónimo.Así, de la palabra algorismo, que originalmente hacía referencia a las reglas de uso de la aritmética utilizando dígitos árabes, se evolucionó a la palabra latina, derivación de al-Khwarizmi, algobarismus, que más tarde mutaría a algoritmo en el siglo XVIII. La palabra ha cambiado de forma que en su definición se incluye a todos los procedimientos finitos para resolver problemas.Ya en el siglo XIX, se produjo el primer algoritmo escrito para un computador. La autora fue Ada Byron, en cuyos escritos se detallaban la máquina analítica en 1842. Por ello que es considerada por muchos como la primera programadora aunque, desde Charles Babbage, nadie completó su máquina, por lo que el algoritmo nunca se implementó.La falta de rigor matemático en la definición de "procedimiento bien definido" para los algoritmos trajo algunas dificultades a los matemáticos y lógicos del siglo XIX y comienzos de XX. Este problema fue en gran parte resuelto con la descripción de la máquina de Turing, un modelo abstracto de computadora formulado por Alan Turing, y la demostración de que cualquier método anticipado por otros matemáticos que pueda encontrarse para describir "procedimientos bien definidos" puede ser emulado en una máquina de Turing (una afirmación conocida como "tesis de Church-Turing").En la actualidad, el criterio formal para definir un algoritmo es que se trata de un proceso que puede implementarse en una máquina de Turing completamente especificada, o en alguno de los formalismos equivalentes. El interés original de Turing era el problema de la detención: decidir cuándo un algoritmo describe un procedimiento de terminación. En términos prácticos importa más la teoría de la complejidad computacional, que incluye los problemas llamados NP-completos, es decir aquellos sobre los que generalmente se presume que requerirán tiempo más que polinómico para cualquier algoritmo (determinístico). NP denota la clase de los problemas de decisión que pueden ser resueltos en tiempo polinómico por una máquina de Turing no determinística.Tipos de algoritmos según su funciónAlgoritmo de ordenamientoAlgoritmo de búsquedaTécnicas de diseño de algoritmosAlgoritmos voraces (greedy): seleccionan los elementos más prometedores del conjunto de candidatos hasta encontrar una solución. En la mayoría de los casos la solución no es óptima.Algoritmos paralelos: permiten la división de un problema en subproblemas de forma que se puedan ejecutar de forma simultánea en varios procesadores.Algoritmos probabilísticos: algunos de los pasos de este tipo de algoritmos están en función de valores pseudoaleatoriosAlgoritmos determinísticos: El comportamiento del algoritmo es lineal: cada paso del algoritmo tiene únicamente un paso sucesor y otro ancesor.Algoritmos no determinísticos: El comportamiento del algoritmo tiene forma de árbol y a cada paso del algoritmo puede bifurcarse a cualquier número de pasos inmediatamente posteriores, además todas las ramas se ejecutan simultáneamente.Divide y vencerás: dividen el problema en subconjuntos disjuntos obteniendo una solución de cada uno de ellos para después unirlas, logrando así la solución al problema completo.Metaheurísticas: encuentran soluciones aproximadas (no óptimas) a problemas basándose en un conocimiento anterior (a veces llamado experiencia) de los mismos.Programación dinámica: intenta resolver problemas disminuyendo su coste computacional aumentando el coste espacial.Ramificación y acotación: se basa en la construcción de las soluciones al problema mediante un árbol implícito que se recorre de forma controlada encontrando las mejores soluciones.Vuelta Atrás (Backtracking): se construye el espacio de soluciones del problema en un árbol que se examina completamente, almacenando las soluciones menos costosas.Temas relacionadosCota superior asintóticaCota inferior asintóticaCota ajustada asintóticaComplejidad computacionalMáquina de TuringDisciplinas relacionadasCiencias de la ComputaciónAnálisis de algoritmosComplejidad computacionalInformáticaInteligencia artificialInvestigación operativaMatemáticasProgramaciónLibros sobre AlgoritmiaFundamentos de Algoritmia, G. Brassard y P. Bratley. (ISBN 848966000)The Art of Computer Programming, Knuth, D. E. fue también, el creador del [[TeX]]Introduction to Algorithms (2nd ed), Cormen, T. H., Leiserson, C. E., Rivest, R. L. y Stein, C.Introduction to Algorithms. A Creative Approach, Mamber, U.Algorithms in C (3r ed), Sedgewick, R. (también existen versiones en C++ y Java)''The Design and Analysis of Computer Algorithms, Aho, A.[http://jjflorescueto.googlepages.com/3erlibro Método de las 6'D. Modelamiento - Algoritmo - Programación. Enfoque orientado a las estructuras lógicas (2da ed.)], Juan José Flores Cueto y Carmen Bertolotti ZuñigaEnlaces externos Portal de algoritmiaConceptos BásicosTécnicas de Diseño de Algoritmos manual que explica y ejemplifica los distintos paradigmas de diseño de algoritmos. Rosa Guerequeta y Antonio Vallecillo (profesores de la Universidad de Málaga).Transparencias de la asignatura &quot;Esquemas Algorítmicos&quot;, Campos, J.Apuntes y problemas de Algorítmica por Domingo Giménez CánovasCurso de Diseño de Algoritmos de Carlos Pes  Categoría:Algoritmosaf:Algoritme an:Algorismo ar:خوارزمية ast:Algoritmu az:Alqoritm be:Алгарытм be-x-old:Альгарытм bg:Алгоритъм bn:অ্যালগোরিদম bs:Algoritam ca:Algorisme cs:Algoritmus da:Algoritme de:Algorithmus el:Αλγόριθμος en:Algorithm eo:Algoritmo et:Algoritm fa:الگوریتم fi:Algoritmi fr:Algorithmique gl:Algoritmo he:אלגוריתם hi:अल्गोरिद्म hr:Algoritam hu:Algoritmus ia:Algorithmo id:Algoritma is:Reiknirit it:Algoritmo ja:アルゴリズム ka:ალგორითმი kaa:Algoritm ko:알고리즘 ku:Algorîtma lb:Algorithmus lt:Algoritmas lv:Algoritms mk:Алгоритам mn:Алгоритм ms:Algoritma nl:Algoritme nn:Algoritme no:Algoritme pl:Algorytm pt:Algoritmo ro:Algoritm ru:Алгоритм sah:Алгоритм sd:الخوارزمي sh:Algoritam simple:Algorithm sk:Algoritmus sl:Algoritem sq:Algoritmi sr:Алгоритам su:Algoritma sv:Algoritm ta:ஆல்கரிதம் te:అల్గారిథం tg:Алгоритм th:ขั้นตอนวิธี tl:Algoritmo tr:Algoritma uk:Алгоритм vi:Thuật toán wa:Algorisse yi:אלגאריטם zh:算法 zh-yue:演算法