C++ es un lenguaje de programación diseñado a mediados de los años 1980 por Bjarne Stroustrup. La intención de su creación fue el extender al exitoso lenguaje de programación C con mecanismos que permitan la manipulación de objetos. En ese sentido, desde el punto de vista de los lenguajes orientados a objetos, el C++ es un lenguaje híbrido.Posteriormente se añadieron facilidades programación genérica, que se sumó a los otros dos paradigmas que ya estaban admitidos (programación estructurada y la programación orientada a objetos). Por esto se suele decir que el C++ es un lenguaje multiparadigma.Actualmente existe un estándar, denominado ISO C++, al que se han adherido la mayoría de los fabricantes de compiladores más modernos. Existen también algunos intérpretes, tales como ROOT (enlace externo).Una particularidad del C++ es la posibilidad de redefinir los operadores (sobrecarga de operadores), y de poder crear nuevos tipos que se comporten como tipos fundamentales.C++ permite trabajar tanto a alto como a bajo nivel.El nombre C++ fue propuesto por Rick Mascitti en el año 1983, cuando el lenguaje fue utilizado por primera vez fuera de un laboratorio científico. Antes se había usado el nombre "C con clases". En C++, la expresión "C++" significa "incremento de C" y se refiere a que C++ es una extensión de C.Un ejemplo de programa en C++, el clásico Hola MundoA continuación se cita un programa de ejemplo un "Hola mundo" escrito en C++:include  // Esta biblioteca permite el uso de cout()using namespace std;int main()  Al usar la directiva #include estamos diciéndole al compilador que busque determinadas cosas en un archivo que se llama iostream. Para evitar redefinir cosas ya hechas al ponerles igual nombre, se creó algo llamado espacios de nombres o namespace en el singular del inglés. En este caso hay un espacio de nombres llamado std, que es donde se incluyen las definiciones, entre muchas otras cosas de los operadores cin y cout, necesarios para la entrada y salida de datos por el dispositivo estándar, típicamente una pantalla o teclado, y todo esto es exactamente lo que decimos al añadir la sentencia using namespace std. La definición de funciones es igual que en C, salvo por la característica de que si main no va a recoger argumentos, no tenemos por qué ponérselos, a diferencia de C, donde había que ponerlos explícitamente, aunque no se fueran a usar. Queda solo comentar que el símbolo  se conoce como operador de inserción, y grosso modo está enviando a cout lo que queremos mostrar por pantalla para que lo pinte, en este caso la cadena "¡Hola mundo!" . El mismo operador  se puede usar varias veces en la misma sentencia, de forma que gracias a esta característica podemos poner un carácter endl al final, que es el equivalente del \n en C o \n\r, según el sistema en que se esté programando.Tipos de datos unsigned char 8 bits 0 a 255 char 8 bits -128 a 127 short int 16 bits -32,768 a 32,767 unsigned int 32 bits 0 a 4,294,967,295 int 32 bits -2,147,483,648 a 2,147,483,647 unsigned long 32 bits 0 a 4,294,967,295 enum 16 bits -2,147,483,648 a 2,147,483,647 long 32 bits -2,147,483,648 a 2,147,483,647 float 32 bits 3.4*10-38 a 3.4*10+38 (6 dec) double 64 bits 1.7*10-308 a 1.7*10+308 (15 dec) long double 80 bits 3.4*10-4932 a 1.1*10+4932 El modificador unsigned se puede aplicar a enteros para obtener números sin signo (por omisión los enteros contienen signo), con lo que se consigue un rango mayor de números naturales.Tamaños Asociados+ Tamaños de tipos primitivos bajo i386 (GCC)TipoNúmero de Bitschar8short16int32float32double64Según la máquina y el compilador que se utilice los tipos primitivos pueden ocupar un determinado tamaño en memoria. La siguiente lista ilustra el número de bits que ocupan los distintos tipos primitivos la arquitectura "x86".Otras arquitecturas pueden requerir distintos tamaños de tipos de datos primitivos. C++ no dice nada acerca de cuál es el número de bits en un byte, ni del tamaño de estos tipos; más bien, ofrece solamente las siguientes "garantías de tipos":Un tipo char tiene el tamaño mínimo en bytes asignable por la máquina, y todos los bits de este espacio deben ser "accesibles".El tamaño reconocido de char es de 1. Es decir, sizeof(char) siempre devuelve 1.Un tipo short tiene al menos el mismo tamaño que un tipo char.Un tipo long tiene al menos el doble tamaño en bytes que un tipo short.Un tipo int tiene un tamaño entre el de short y el de long, ambos inclusive, preferentemente el tamaño de un apuntador de memoria de la máquina.Un tipo unsigned tiene el mismo tamaño que su versión signed.wchar_tPara la versión del estándar que se publicó en 1999, se decidió añadir el tipo de dato wchar_t, que permite el uso de caracteres UNICODE, a diferencia del tradicional char, que contempla simplemente al código de caracteres ASCII extendido. A su vez, se ha definido para la mayoría de las funciones y clases, tanto de C como de C++, una versión para trabajar con wchar_t, donde usualmente se prefija el carácter w al nombre de la función (en ocasiones el carácter es un infijo). Por ejemplo:strcpy - wstrcpystd::string - std::wstringstd::cout - std::wcoutCabe resaltar que en C se define wchar_t como: typedef unsigned short wchar_t; Mientras que en C++ es en sí mismo un tipo de dato.La Palabra Clave &quot;void&quot;La palabra clave void define en C++ el concepto de no existencia o no atribución de un tipo en una variable o declaración. Como tal, puede ser usada para destacar que una función no recibe parámetros, como en:  int funcion (void);    , aunque la tendencia actual es la de no colocar la palabra "void".Además se utiliza para determinar que una función no retorna un valor, como en:  void funcion (int parametro); Cabe destacar que void no es un tipo. Una función como la declarada anteriormente no puede retornar un valor por medio de return: la palabra clave va sola. No es posible una declaración del tipo:  void t; En este sentido, void se comporta de forma ligeramente diferente a como lo hace en C, especialmente en cuanto a su significado en declaraciones y prototipos de funciones.Sin embargo, la forma especial void * puede utilizarse como un ajuste que convierte cualquier variable a una "variable sin tipo", la cual puede solo ser accedida y utilizada bajo una operación de cast. Por ejemplo: void *memoria; Indica que memoria es un puntero a alguna parte, donde se guarda información de algún tipo. El programador es responsable de definir estos "algún", eliminando toda ambigüedad. Una ventaja de la declaración "void *" es que puede representar a la vez varios tipos de datos, dependiendo de la operación de cast escogida. La memoria que hemos apuntado en alguna parte, en el ejemplo anterior, bien podría almacenar un entero, un flotante, una cadena de texto o un programa, o combinaciones de éstos. Es responsabilidad del programador recordar qué tipo de datos hay y garantizar el acceso adecuado.PrincipiosTodo programa en C++ debe tener la función main() (a no ser que se especifique en tiempo de compilación otro punto de entrada, que en realidad es la función que tiene el main())  int main()  La función main debe tener uno de los siguientes prototipos: int main() int main(int argc, char** argv)La primera es la forma por omisión de un programa que no recibe parámetros ni argumentos. La segunda forma tiene dos parámetros: argc, un número que describe el número de argumentos del programa (incluyendo el nombre del programa mismo), y argv, un puntero a un array de punteros, de argc elementos, donde el elemento argvi representa el i-ésimo argumento entregado al programa.El tipo de retorno de main es int. Al finalizar la función main, debe incluirse el valor de retorno (por ejemplo, return 0;, aunque el estándar prevé solamente dos posibles valores de retorno: EXIT_SUCCESS y EXIT_ERROR, definidas en el archivo cstddef), o salir por medio de la función exit. Alternativamente puede dejarse en blanco, en cuyo caso el compilador es responsable de agregar la salida adecuada.El Concepto de ClaseLos objetos en C++ son abstraídos mediante una Clase. Según el paradigma de la programación orientada a objetos un objeto consta de:Métodos o funcionesAtributos o Variables MiembroUn ejemplo de clase que podemos tomar es la clase perro. Cada perro comparte unas características (atributos). Su número de patas, el color de su pelaje o su tamaño son algunos de sus atributos. Las funciones que lo hagan ladrar, cambiar su comportamiento... esas son las funciones de la clase.Este es otro ejemplo de una clase: class Punto ; ConstructoresSon unos métodos especiales que se ejecutan automáticamente al crear un objeto de la clase. En su declaración no se especifica el tipo de dato que devuelven, y poseen el mismo nombre que la clase a la que pertenecen. Al igual que otros métodos, puede haber varios constructores sobrecargados, aunque no pueden existir constructores virtuales.Como característica especial a la hora de implementar un constructor, justo después de la declaración de los parámetros, se encuentra lo que se llama "lista de inicializadores". Su objetivo es llamar a los constructores de los atributos que conforman el objeto a construir.Cabe destacar que no es necesario declarar un constructor al igual que un destructor, pues el compilador lo puede hacer, aunque no es la mejor forma de programar.Tomando el ejemplo de la Clase Punto, si deseamos que cada vez que se cree un objeto de esta clase las coordenadas del punto sean igual a cero podemos agregar un constructor como se muestra a continuación: class Punto ;// Main para demostrar el funcionamiento de la claseinclude  // Esto nos permite utilizar "cout"using namespace std;int main()  Si compilamos y ejecutamos el anterior programa, obtenemos una salida que debe ser similar a la siguiente:Coordenada X:0 Coordenada Y:0Existen varios tipos de constructores en C++:Constructor predeterminado. Es el constructor que no recibe ningún parámetro en la función. Si no se definiera ningún constructor, el sistema proporcionaría uno predeterminado. Es necesario para la construcción de estructuras y contenedores de la STL.Constructor de copia. Es un constructor que recibe un objeto de la misma clase, y realiza una copia de los atributos del mismo. Al igual que el predeterminado, si no se define, el sistema proporciona uno.Constructor de conversión. Este constructor, recibe como único parámetro, un objeto o variable de otro tipo distinto al suyo propio. Es decir, convierte un objeto de un tipo determinado a otro objeto del tipo que estamos generando.DestructoresLos destructores son funciones miembro especiales llamadas automáticamente en la ejecución del programa, y por tanto no tienen por qué ser llamadas explícitamente por el programador. Su cometido es liberar los recursos computacionales que el objeto de dicha clase haya adquirido en tiempo de ejecución al expirar este.Los destructores son invocados automáticamente al alcanzar el flujo del programa el fin del ámbito en el que está declarado el objeto.Existen dos tipos de destructores pueden ser públicos o privados, según si se declaran:si es publico se llama desde cualquier parte del programa para destruir el objeto.si es privado no se permite la destrucción del objeto por el usuario.Funciones MiembroFunción miembro es aquella que está declarada en ámbito de clase. Son similares a las funciones habituales, con la salvedad de que el compilador realizara el proceso de Decoración de nombre (Name Mangling en inglés): Cambiara el nombre de la función añadiendo un identificador de la clase en la que está declarada, pudiendo incluir caracteres especiales o identificadores numéricos. Además, las funciones miembro reciben implícitamente un parámetro adicional: El puntero this, que referencia al objeto que ejecuta la función.Las funciones miembro se invocan accediendo primero al objeto al cual refieren, con la sintaxis: myobject.mymemberfunction(), esto es un claro ejemplo de una función miembro.. a // Clase Punto //----------------------------------------------------------------------- class Punto ; //-----------------------------------------------------------------------// Main para demostrar el funcionamiento de la claseinclude  // Esto nos permite utilizar la función COUTusing namespace std;int main()  Si compilamos y ejecutamos el anterior programa, obtenemos una salida que debe ser similar a la siguiente:Coordenada X:0 Coordenada Y:0PlantillasLas plantillas son el mecanismo de C++ para implantar el paradigma de la programación genérica. Permiten que una clase o función trabaje con tipos de datos abstractos, especificándose más adelante cuales son los que se quieren usar. Por ejemplo, es posible construir un vector genérico que pueda contener cualquier tipo de estructura de datos. De esta forma se pueden declarar objetos de la clase de este vector que contengan enteros, flotantes, polígonos, figuras, fichas de personal, etc.La declaración de una plantilla se realiza anteponiendo la declaración template  a la declaración de la estructura (clase, estructura o función) deseado.Por ejemplo: template  T max(T x, T y)  La función max() es un ejemplo de programación genérica, y dados dos parámetros de un tipo T (que puede ser int, long, float, double, etc.) devolverá el mayor de ellos (usando el operador &gt;). Al ejecutar la función con parámetros de un cierto tipo, el compilador intentará "calzar" la plantilla a ese tipo de datos, o bien generará un mensaje de error si fracasa en ese proceso.EspecializaciónEl siguiente ejemplo: template  int myfunction(A a); crea una plantilla bajo la cual pueden ser definidas en el código de cabecera cualesquiera funciones especializadas para un tipo de datos como int myfunction(int), int myfunction(std::string), int myfunction(bool), etcétera: int myfunction (int a) ;int myfunction (std::string a) ;int myfunction (bool a) ; Cada una de estas funciones tiene su propia definición (cuerpo). Cada cuerpo diferente, no equivalente ("no convertible") corresponde a una especialización. Si una de estas funciones no fuera definida, el compilador tratará de aplicar las conversiones de tipos de datos que le fuesen permitidas para "calzar" una de las plantillas, o generará un mensaje de error si fracasa en ese proceso.Todas las definiciones habilitadas de una plantilla deben estar disponibles al momento de la compilación, por lo cual no es posible actualmente "compilar" una plantilla como archivo de objeto, sino simplemente compilar especializaciones de la plantilla. Por lo tanto, las plantillas se distribuyen junto con el código fuente de la aplicación. En otras palabras, no es posible compilar la plantilla std::vector a código objeto, pero sí es posible, por ejemplo, compilar un tipo de datos std::vector.Clases AbstractasEn C++ es posible definir clases abstractas. Una clase abstracta, o clase base abstracta (ABC), es una que está diseñada sólo como clase padre de las cuales se deben derivar clases hijas. Una clase abstracta se usa para representar aquellas entidades o métodos que después se implementarán en las clases derivadas, pero la clase abstracta en sí no contiene ninguna implementación -- solamente representa los métodos que se deben implementar. Por ello, no es posible instanciar una clase abstracta, pero sí una clase concreta que implemente los métodos definidos en ella.Las clases abstractas son útiles para definir interfaces, es decir, un conjunto de métodos que definen el comportamiento de un módulo determinado. Estas definiciones pueden utilizarse sin tener en cuenta la implementación que se hará de ellos.En C++ los métodos de las clases abstractas se definen como funciones virtuales puras. class Abstracta ;class ConcretaA : public Abstracta ;class ConcretaB : public Abstracta ;  En el ejemplo, la clase ConcretaA es una implementación de la clase Abstracta, y la clase ConcretaB es otra implementación. Debe notarse que el = 0 es la notación que emplea C++ para definir funciones virtuales puras.Espacios de NombresUna adición a las características de C son los espacios de nombre (namespace en inglés), los cuales pueden describirse como áreas virtuales bajo las cuales ciertos nombres de variable o tipos tienen validez. Esto permite evitar las ocurrencias de conflictos entre nombres de funciones, variables o clases.El ejemplo más conocido en C++ es el espacio de nombres std::, el cual almacena todas las definiciones nuevas en C++ que difieren de C (algunas estructuras y funciones), así como las funcionalidades propias de C++ (streams) y los componentes de la biblioteca STL.Por ejemplo:include // Las funciones en esta cabecera existen dentro del espacio de nombres std::namespace mi_paquete;int main()  Como puede verse, las invocaciones directas a mi_valor darán acceso solamente a la variable descrita localmente; para acceder a la variable del paquete mi_paquete es necesario acceder específicamente el espacio de nombres. Un atajo recomendado para programas sencillos es la directiva using namespace, que permite acceder a los nombres de variables del paquete deseado en forma directa, siempre y cuando no se produzca alguna ambigüedad o conflicto de nombres.=== Excepciones === C++ permite la existencia de excepciones, las cuales son una metodología de flujo de ejecución basada en la prueba del código deseado (try) seguida por la intercepción de ciertas condiciones bajo un flujo de programa adicional (catch). La declaración de estas condiciones se hace "arrojando" (throw) sentencias especiales que son capturadas por el flujo catch correspondiente.Por ejemplo:include // Muestra el uso de try y catchint main()  catch (std::exception& X)  return 0; En el ejemplo anterior, se hace el intento de acceder al caracter número 99 de la cadena "Hola Mundo", el cual no existe. El tipo de datos std::string arroja en estos casos, en la llamada a la función "at", una excepción, del tipo std::out_of_range, derivado de std::exception. El bloque catch "atrapará" la excepción arrojada como una variable X, para la cual el método what() muestra un mensaje con la causa del error (en nuestro caso, un mensaje similar a "Index Out of Range").Es buena idea al crear nuevas excepciones derivarlas de std::exception ya que es el bloque catch que muchos programadores colocan por omisión.Si una excepción se propaga sin ser atrapada por un bloque catch, y llegara hasta el punto de terminación del programa, se produce la terminación abrupta de éste ("abort").HerenciaExisten varios tipos de herencia entre clases en el lenguaje de programación C++. Estos son:Herencia SimpleLa herencia en C++ es un mecanismo de abstracción creado para poder facilitar, y mejorar el diseño de las clases de un programa. Con ella se pueden crear nuevas clases a partir de clases ya hechas, siempre y cuando tengan un tipo de relación especial.En la herencia, las clases derivadas "heredan" los datos y las funciones miembro de las clases base, pudiendo las clases derivadas redefinir estos comportamientos (polimorfismo) y añadir comportamientos nuevos propios de las clases derivadas. Para no romper el principio de encapsulamiento (ocultar datos cuyo conocimiento no es necesario para el uso de las clases), se proporciona un nuevo modo de visibilidad de los datos/funciones: "protected". Cualquier cosa que tenga visibilidad protected se comportará como pública en la clase Base y en las que componen la jerarquía de herencia, y como privada en las clases que NO sean de la jerarquía de la herencia.Antes de utilizar la herencia, nos tenemos que hacer una pregunta, y si tiene sentido, podemos intentar usar esta jerarquía: Si la frase  ES-UN  tiene sentido, entonces estamos ante un posible caso de herencia donde clase A será la clase base y clase B la derivada.Ejemplo: clases Barco, Acorazado, Carguero, etc. un Acorazado ES-UN Barco, un Carguero ES-UN Barco, un Trasatlántico ES-UN Barco, etc.En este ejemplo tendríamos las cosas generales de un Barco (en C++)  class Barco ;  y ahora las características de las clases derivadas, podrían (a la vez que heredan las de barco) añadir cosas propias del subtipo de barco que vamos a crear, por ejemplo: class Carguero: public Barco ;class Acorazado: public Barco ; Por último, hay que mencionar que existen 3 clases de herencia que se diferencian en el modo de manejar la visibilidad de los componentes de la clase resultante:Herencia publica (class Derivada: public Base ) : Con este tipo de herencia se respetan los comportamientos originales de las visibilidades de la clase Base en la clase Derivada.Herencia privada (clase Derivada: private Base) : Con este tipo de herencia todo componente de la clase Base, será privado en la clase Derivada (ojo! siempre será privado aunque ese dato fuese público en la clase Base)Herencia protegida (clase Derivada: protected Base) : Con este tipo de herencia, todo componente publico y protegido de la clase Base, será protegido en la clase Derivada, y los componentes privados, siguen siendo privados.Herencia MúltipleLa herencia múltiple es el mecanismo que permite al programador hacer clases derivadas a partir, no de una sola clase base, sino de varias. Para entender esto mejor, pongamos un ejemplo: Cuando ves a quien te atiende en una tienda, como persona que es, podrás suponer que puede hablar, comer, andar, pero, por otro lado, como empleado que es, también podrás suponer que tiene un jefe, que puede cobrarte dinero por la compra, que puede devolverte el cambio, etc. Si esto lo trasladamos a la programación sería herencia múltiple (clase empleado_tienda): class Persona ;class Empleado ;class empleado_tienda: public Persona, Empleado ; Por tanto, es posible utilizar más de una clase para que otra herede sus características.Sobrecarga de OperadoresLa sobrecarga de operadores es una forma de hacer polimorfismo. Es posible definir el comportamiento de un operador del lenguaje para que trabaje con tipos de datos definidos por el usuario. No todos los operadores de C++ son factibles de sobrecargar, y, entre aquellos que pueden ser sobrecargados, se deben cumplir condiciones especiales. En particular, los operadores sizeof y :: no son sobrecargables.No es posible en C++ crear un operador nuevo.Los comportamientos de los operadores sobrecargados se implementan de la misma manera que una función, salvo que esta tendrá un nombre especial: Tipo de dato de devolución operator(parámetros)Los siguientes operadores pueden ser sobrecargados:Operadores UnariosOperador * (de indirección)Operador - (de indirección)Operador +Operador -Operador ++Operador --Operadores BinariosOperador ==Operador +Operador -Operador *Operador /Operador %Operador Operador &Operador ^Operador |Operador []Operador ()Operadores de AsignaciónOperador =Operador +=Operador -=Operador *=Operador /=Operador %=Operador =Operador &=Operador ^=Operador |=* Dado que estos operadores son definidos para un tipo de datos definido por el usuario, éste es libre de asignarles cualquiera semántica que desee. Sin embargo, se considera de primera importancia que las semánticas sean tan parecidas al comportamiento natural de los operadores como para que el uso de los operadores sobrecargados sea intuitivo. Por ejemplo, el uso del operador unario - debiera cambiar el "signo" de un "valor".Los operadores sobrecargados no dejan de ser funciones, por lo que pueden devolver un valor, si este valor es del tipo de datos con el que trabaja el operador, permite el encadenamiento de sentencias. Por ejemplo, si tenemos 3 variables A,B y C de un tipo T y sobrecargamos el operador = para que trabaje con el tipo de datos T, hay dos opciones: si el operador no devuelve nada una sentencia como "A=B=C;" (sin las comillas) daría error, pero si se devuelve un tipo de datos T al implementar el operador, permitiría concatenar cuantos elementos se quisieran, permitiendo algo como "A=B=C=D=...;"Biblioteca Estándar de Plantillas (STL, Standard Template Library)Los lenguajes de programación suelen tener una serie de bibliotecas de funciones integradas para la manipulación de datos a nivel más básico. En C++, además de poder usar las bibliotecas de C, se puede usar la nativa STL (Standard Template Library), propia del lenguaje. Proporciona una serie plantillas (templates) que permiten efectuar operaciones sobre el almacenado de datos, procesado y flujos de entrada/salida.Biblioteca de entrada y salidaLas clases basic_ostream y basic_stream, y los objetos cout y cin, proporcionan la entrada y salida estándar de datos (teclado/pantalla). También está disponible cerr, similar a cout, usado para la salida estándar de errores. Estas clases tienen sobrecargados los operadores , respectivamente, con el objeto de ser útiles en la inserción/extracción de datos a dichos flujos. Son operadores inteligentes, ya que son capaces de adaptarse al tipo de datos que reciben, aunque tendremos que definir el comportamiento de dicha entrada/salida para clases/tipos de datos definidos por el usuario. Por ejemplo: ostream& operatorDe esta forma, para mostrar un punto, solo habría que realizar la siguiente expresión:  //... Punto p(4,5); //... cout Es posible formatear la entrada/salida, indicando el número de dígitos decimales a mostrar, si los textos se pasarán a minúsculas o mayúsculas, si los números recibidos están en formato octal o hexadecimal, etc.fstreamsTipo de flujo para el manejo de ficheros. La definición previa de ostreams/istreams es aplicable a este apartado. Existen tres clases (ficheros de lectura, de escritura o de lectura/escritura): ifstream,ofstream y fstream.Como abrir un fichero: (nombre_variable_fichero).open("nombre_fichero.dat/txt",ios::in); para abrirlo en modo lectura. (nombrevariablefichero).open("nombre_fichero.dat/txt",ios::out); para abrirlo en modo escritura.Ejemplo: f.open("datos.txt",ios::in);Como cerrar el fichero: nombre_variable_fichero.close();Ejemplo: f.close();Leer un fichero:1-Si es fichero de texto(.txt):
  nombrevariable&gt;&gt;&quot;texto&quot;;  Ejemplo: f&gt;&gt;HOLA;2-Si es un fichero binario(.dat);
  nombre_variable_fichero.read((char*)&amp;nombre_variable,sizeof(tipo_variable));  Ejemplo:  f.read((char*)&amp;e,sizeof(int));Escribir un fichero:1-Si es fichero de texto(.txt):
  nombrevariable&lt;&lt;&quot;texto&quot;;  Ejemplo: f&lt;&lt;HOLA;2-Si es un fichero binario(.dat);
  nombre_variable_fichero.write((char*)&amp;nombre_variable,sizeof(tipo_variable));  Ejemplo:  f.write((char*)&amp;e,sizeof(int));Pueden abrirse pasando al constructor los parámetros relativos a la ubicación del fichero y el modo de apertura: